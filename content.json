{"meta":{"title":"逃亡之人","subtitle":"相与不难，相知不易","description":"相与不难，相知不易","author":"kbrx93","url":"https://hexo.kbrx93.com"},"pages":[{"title":"胡言乱语","date":"2017-10-13T06:25:14.000Z","updated":"2018-11-24T16:57:31.000Z","comments":false,"path":"about/index.html","permalink":"https://hexo.kbrx93.com/about/index.html","excerpt":"","text":"出生南方，坎坷未经，未感天寒地冻； 生性懒散，不喜出门，不曾路遥马亡。 广东潮汕人，理工男一枚。 在慢慢地成熟，希望快些。 时间不等人。 以我所理解的方式热爱着生活，感恩身边的每个人，每件事。 活着真好， 祝安。"},{"title":"categories","date":"2017-10-11T01:09:23.000Z","updated":"2018-11-24T16:57:31.000Z","comments":false,"path":"categories/index.html","permalink":"https://hexo.kbrx93.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-10-11T01:07:50.000Z","updated":"2018-11-24T16:57:31.000Z","comments":false,"path":"tags/index.html","permalink":"https://hexo.kbrx93.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java杂记（九）Math.abs 方法的一个小坑.md","slug":"2018-05-23Java杂记（九）Math.abs 方法的一个小坑","date":"2018-05-22T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Notes-Math-abs-question/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Notes-Math-abs-question/","excerpt":"前言：在一个「星球」上看到一个小问题「Math.abs方法一定返回负数吗？」，感觉蛮有趣的，特记录一下。","text":"前言：在一个「星球」上看到一个小问题「Math.abs方法一定返回负数吗？」，感觉蛮有趣的，特记录一下。 主要过程 我们知道 Math.abs() 这个方法是返回一个数的绝对值，那么会不会出现返回负数的情况呢？ 源码 先来看一看源码（以 int 为例）： public static int abs(int a) { return (a &lt; 0) ? -a : a; } 其实就是简单地取反过程，本身没有什么问题，但联想到在计算机中数以补码的形式存在，也就是负数比正数多一个，int 的范围为 -2147483648 ~ 2147483647，所以当传入的数为 Integer.MIN_VALUE 的时候就会溢出，所以会返回一个负数。 其实在 JavaDoc 中也早有说明： Returns the absolute value of an int value. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned. Note that if the argument is equal to the value of Integer.MIN_VALUE, the most negative representable int value, the result is that same value, which is negative. 其它的特例 看完了 int 的例子，罗例一下其它类型的特例。 long Note that if the argument is equal to the value of Long.MIN_VALUE, the most negative representable long value, the result is that same value, which is negative. float Special cases: If the argument is positive zero or negative zero, the result is positive zero. If the argument is infinite, the result is positive infinity. If the argument is NaN, the result is NaN. In other words, the result is the same as the value of the expression: Float.intBitsToFloat(0x7fffffff &amp; Float.floatToIntBits(a)) double Special cases: If the argument is positive zero or negative zero, the result is positive zero. If the argument is infinite, the result is positive infinity. If the argument is NaN, the result is NaN. In other words, the result is the same as the value of the expression: Double.longBitsToDouble((Double.doubleToLongBits(a)&lt;&lt;1)&gt;&gt;&gt;1) 小结 虽然不是什么很重要的知识点，但多了解一点总没错。","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"math","slug":"math","permalink":"https://hexo.kbrx93.com/tags/math/"},{"name":"abs","slug":"abs","permalink":"https://hexo.kbrx93.com/tags/abs/"},{"name":"正负数","slug":"正负数","permalink":"https://hexo.kbrx93.com/tags/正负数/"}]},{"title":"Java容器源码（二）LinkedList部分源码分析","slug":"2018-04-26Java容器源码（二）LinkedList部分源码分析","date":"2018-05-21T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-SourceCode-LinkedList/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-SourceCode-LinkedList/","excerpt":"前言：LinkedList 是 Java 中非常重要的集合类，本质上就是一个数据存储的数据结构。底层是用链表来实现的。这个类注意与 ArrayList 对比","text":"前言：LinkedList 是 Java 中非常重要的集合类，本质上就是一个数据存储的数据结构。底层是用链表来实现的。这个类注意与 ArrayList 对比 继承关系 常用方法、内部类及变量 维护的变量 transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; Node 内部类（三元组） private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; } } 构造方法 LinkedList() /** * Constructs an empty list. */ public LinkedList() { } LinkedList(Collection&lt;? extends E&gt; c) /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public LinkedList(Collection&lt;? extends E&gt; c) { this(); addAll(c); } add 方法 add(E e): boolean public boolean add(E e) { // 将节点 e 增加到链表的最后 linkLast(e); return true; } add(int index, E element): void /** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any * subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException {@inheritDoc} */ public void add(int index, E element) { //在指定的位置增加节点 // index &gt;= 0 &amp;&amp; index &lt;= size 就报错 IndexOutOfBoundsException checkPositionIndex(index); // 索引值正好等于节点个数，则直接调用 linkLast 增加在节点的最尾处 // 如果不相等，则调用 node 方法返回对应索引的结点，然后 调用 linkBefore 方法， // 将新元素加到 原结点之前 // 注意这果 node 方法返回的节点一点非空，因为索引值在最开始就检查过了 if (index == size) linkLast(element); else linkBefore(element, node(index)); } linkLast(E e): void /** * Links e as last element. */ void linkLast(E e) { // 保存一下尾指点 final Node&lt;E&gt; l = last; // 生成新的结点，新结点的前置指针指向链表的最后，后置为空 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 将 last 指向新生成的结点 last = newNode; // 如果 l 为空，换言之，这是添加的第一个节点，则将 first 指向新结点 // 如空不为空，则将链表的最后结点的后置指针指向新结点 if (l == null) first = newNode; else l.next = newNode; size++; modCount++; } linkBefore(E e, Node succ): void /** * Inserts element e before non-null Node succ. */ void linkBefore(E e, Node&lt;E&gt; succ) { // assert succ != null; // 跟 linkLast 一样的套路 /** * 1. 先保存前一个节点指针 * 2. 生成新结点，新结点前置为前一个节点，后置为传入节点 * 3. 传入节点的前置修改为新结点 * 4. 判断前上个节点是否存在，如果不存在，则说明新生成的节点应该在最开始，所以 first = newNode * 如果存在，则前一个节点的后置指针指向新生成的节点 */ final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; } remove 方法 remove(): E /** * Retrieves and removes the head (first element) of this list. * * @return the head of this list * @throws NoSuchElementException if this list is empty * @since 1.5 */ public E remove() { // 默认移除第一个 return removeFirst(); } remove(int index): E /** * Removes the element at the specified position in this list. Shifts any * subsequent elements to the left (subtracts one from their indices). * Returns the element that was removed from the list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException {@inheritDoc} */ public E remove(int index) { checkElementIndex(index); // node 方法找到对应结点，unlink 方法除掉它 return unlink(node(index)); } unlinkLast 及 unlink 方法 /** * Unlinks non-null last node l. */ private E unlinkLast(Node&lt;E&gt; l) { // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; } /** * Unlinks non-null node x. */ E unlink(Node&lt;E&gt; x) { // assert x != null; // 保存节点对应信息 final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; modCount++; return element; } indexOf(Object o): int /** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index {@code i} such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. * * @param o element to search for * @return the index of the first occurrence of the specified element in * this list, or -1 if this list does not contain the element */ public int indexOf(Object o) { // 寻找索引，没有什么意外，遍历 int index = 0; if (o == null) { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (x.item == null) return index; index++; } } else { for (Node&lt;E&gt; x = first; x != null; x = x.next) { if (o.equals(x.item)) return index; index++; } } return -1; }","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://hexo.kbrx93.com/tags/源码/"},{"name":"容器","slug":"容器","permalink":"https://hexo.kbrx93.com/tags/容器/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://hexo.kbrx93.com/tags/LinkedList/"}]},{"title":"Java容器源码（一）ArrayList部分源码分析","slug":"2018-04-25Java容器源码（一）ArrayList部分源码分析","date":"2018-05-02T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-SourceCode-ArrayList/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-SourceCode-ArrayList/","excerpt":"前言：ArrayList 是 Java 中非常重要的集合类，本质上就是一个数据存储的数据结构。底层是用数组来实现的。","text":"前言：ArrayList 是 Java 中非常重要的集合类，本质上就是一个数据存储的数据结构。底层是用数组来实现的。 继承关系 常用方法、内部类及变量 构造方法 ArrayList(): void /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() { // DEFAULTCAPACITY_EMPTY_ELEMENTDATA 是一个默认空的 Object 数组 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } ArrayList(Collection&lt;? extends E&gt; c): void /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) { // 提供一个与 c 对应的对象数组副本 // 可用作 new ArrayList(Arrays.asList(Object[] os))，获取 \"真正\" 的 ArrayList。 elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) /** * 如果有元素存在的话，再进行类型的判断，如果得到的运行期的 class 类型不为 Object， * 则再进行复制转型。 * 需要这一步的原因是因为 toArray 方法只能保证返回的数组类型是 Object[]，但是实际 * 的类型却是由 new 来决定的。举个例子 Father类 * Object[] os = new Father[5] * os[0] = new Other() 这一句就会报错，因为 os 实际的类型是 class [LArrayTest$Father; */ if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } add 方法 ensureCapacityInternal 方法 private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } ensureExplicitCapacity 方法 private void ensureExplicitCapacity(int minCapacity) { // 记录对内部结构的修改次数，增加删除元素及扩容操作都需要增加 1 modCount++; // overflow-conscious code // 如果容量不够这一次 add 操作，即 elementData 数组是全满的状态，则进入扩容操作 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); } 扩容 /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) { // overflow-conscious code // 原来数组的大小 int oldCapacity = elementData.length; // 新数组大小 = 旧数组大小 * 1.5，并对新数组大小进行一些验证 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 新数组大小不够这一次 add 操作的时候，将新数组大小改为最小需要的数组大小，当数组原来大小是 0 时会需要这一判断 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //当新数组大小超过规定的最大值（Integer.MAX_VALUE - 8）时， if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 如果 minCapacity 小于 0，则说明溢出了，抛出 OOM // 否则 return (minCapacity &gt; MAX_ARRAY_SIZE) ? // Integer.MAX_VALUE : // MAX_ARRAY_SIZE; newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: //复制操作 elementData = Arrays.copyOf(elementData, newCapacity); } Arrays.copyOf 方法 public static &lt;T&gt; T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass()); } 上面调用的 copyOf 方法 /** * Copies the specified array, truncating or padding with nulls (if necessary) * so the copy has the specified length. For all indices that are * valid in both the original array and the copy, the two arrays will * contain identical values. For any indices that are valid in the * copy but not the original, the copy will contain &lt;tt&gt;null&lt;/tt&gt;. * Such indices will exist if and only if the specified length * is greater than that of the original array. * The resulting array is of the class &lt;tt&gt;newType&lt;/tt&gt;. * * @param &lt;U&gt; the class of the objects in the original array * @param &lt;T&gt; the class of the objects in the returned array * @param original the array to be copied * @param newLength the length of the copy to be returned * @param newType the class of the copy to be returned * @return a copy of the original array, truncated or padded with nulls * to obtain the specified length * @throws NegativeArraySizeException if &lt;tt&gt;newLength&lt;/tt&gt; is negative * @throws NullPointerException if &lt;tt&gt;original&lt;/tt&gt; is null * @throws ArrayStoreException if an element copied from * &lt;tt&gt;original&lt;/tt&gt; is not of a runtime type that can be stored in * an array of class &lt;tt&gt;newType&lt;/tt&gt; * @since 1.6 */ public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) { // 判断原来数组的类型是不是 Object，如果是，直接生成一个新 Object 数组， // 如果不是，则 Array.newInstance 方法（底层也是一个 native 方法）生成一个对应类对象类型的数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); // 这个方法是一个 native 方法， // 表示从 original 数组的第 0 个位置开始复制到 copy 数组的 第 0 个位置， // 复制长度为Math.min(original.length, newLength) System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } remove 方法 remove(Object o): boolean /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */ public boolean remove(Object o) { // 如果传入的对象为空，则进行遍历，当遇到第一个为空的元素时， // 则进入 fastRemove，而这个方法本质上就是将后面的数组组元素直接向前移动一位 // 因为不用返回对象（null） if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { //传入的对象不空，还是一个遍历，用 equals 方法逐一进行比较，如果相等则进入 fastRemove，并返回 true for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } remove(int index): E /** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException {@inheritDoc} */ public E remove(int index) { // 检查传入的索引是否大于数组元素的个数 // 如果大的话，则抛 IndexOutOfBoundsException // 如果传入的负数的话，则在运行 elementData[index] 的时候就会报错，所以不用关心， // 而这里只因为数组的大小在大多数情况下是大于元素个数的，后面的一部分为 null rangeCheck(index); // 修改次数 + 1 modCount++; // 查询旧值 E oldValue = elementData(index); // 元素移动的个数 int numMoved = size - index - 1; // 移动数组后面的元素，即后面的元素向前移动一个单元 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后的元素置 null，帮助 GC elementData[--size] = null; // clear to let GC do its work return oldValue; } toArray(T[] a): T[] /** * Returns an array containing all of the elements in this list in proper * sequence (from first to last element); the runtime type of the returned * array is that of the specified array. If the list fits in the * specified array, it is returned therein. Otherwise, a new array is * allocated with the runtime type of the specified array and the size of * this list. * * &lt;p&gt;If the list fits in the specified array with room to spare * (i.e., the array has more elements than the list), the element in * the array immediately following the end of the collection is set to * &lt;tt&gt;null&lt;/tt&gt;. (This is useful in determining the length of the * list &lt;i&gt;only&lt;/i&gt; if the caller knows that the list does not contain * any null elements.) * * @param a the array into which the elements of the list are to * be stored, if it is big enough; otherwise, a new array of the * same runtime type is allocated for this purpose. * @return an array containing the elements of the list * @throws ArrayStoreException if the runtime type of the specified array * is not a supertype of the runtime type of every element in * this list * @throws NullPointerException if the specified array is null */ @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) { // 如果传入的数组长度不够，则返回一个刚好大小的的新数组 if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // 长度够，则进行深度拷贝 System.arraycopy(elementData, 0, a, 0, size); // 如果传入的数组空间有剩余的话，则有用元素的后一位置为 null， // 这样做是可以帮助使用者判断数组的大小，可以看作是提供一个完结标识 if (a.length &gt; size) a[size] = null; return a; }","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://hexo.kbrx93.com/tags/源码/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://hexo.kbrx93.com/tags/ArrayList/"},{"name":"容器","slug":"容器","permalink":"https://hexo.kbrx93.com/tags/容器/"}]},{"title":"Java 杂记（八）反射之数组参数类型坑","slug":"2018-04-18Java杂记（八）反射之数组参数类型坑","date":"2018-04-17T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Notes-Reflect-Array-Varargs/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Notes-Reflect-Array-Varargs/","excerpt":"前言：在「每日一题」的公众号上又看到一道有趣的题，是关于反射与数组参数的坑。记录一下。","text":"前言：在「每日一题」的公众号上又看到一道有趣的题，是关于反射与数组参数的坑。记录一下。 程序如下： public class Test { public void func(String[] args) { System.out.println((args == null) ? \"null\" : args.length); } public static void main(String[] args) throws Exception { Test obj = new Test(); Method m = obj.getClass().getMethod(\"func\", String[].class); m.invoke(obj, new String[1]); //1 m.invoke(obj, new Object[]{new String[] {\"a\", \"b\"}}); //2 m.invoke(obj, (Object) new String[] {\"a\", \"b\"}); //3 m.invoke(obj, new String[] {\"a\"}); //4 m.invoke(obj, new String[] {\"a\", \"b\"}); //5 m.invoke(obj, new String[2]); //6 } } 结果如下： 解析： 这东西就跟脱衣服一样，因为 invoke 中后一个参数是可变参数，所以只有一个参数传进入的时候是会自动拆解（脱），具体解释一下。 new String[] 这里发现只有一个参数 new String[1]，自动拆解（脱了一层）发现只有一个 null，没办法，传给 func 方法吧，所以结果是 null。 new Object[]{new String[] {“a”, “b”}}) 同上脱了一层，发现是个 String[]，传给方法，简直 perfect (Object) new String[] {“a”, “b”}) 转成 Object 了（加了一层外衣？！），发现只有一个参数，脱吧，发现里面是一个 String[]，传给方法，搞定。 new String[] {“a”} 按例子脱，发现里面是一个 a，是一个字符串，可我想要的是一个 String数组啊，不行，报错。前面的 null 可以是任意类型，String 可不行啊。 new String[] {“a”, “b”} &amp;&amp; new String[2] 脱，发现有两个参数（a 和 b 或 null 和 null），一个给了args，另一个没 有给的对象（没对象？！）所以自然报错啦。 func 急忙说，大兄dei，我可不会帮你穿的，我不是，我没有，别乱说。 小结 总的来说，就是单个参数 + 可变参数 = 可能会自动拆解","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"reflect","slug":"reflect","permalink":"https://hexo.kbrx93.com/tags/reflect/"},{"name":"array","slug":"array","permalink":"https://hexo.kbrx93.com/tags/array/"},{"name":"varargs","slug":"varargs","permalink":"https://hexo.kbrx93.com/tags/varargs/"}]},{"title":"Java杂记（七）关于Java中访问修饰符protected的一个小疑问","slug":"2018-04-08Java杂记（七）关于Java中访问修饰符protected的一个小疑问","date":"2018-04-07T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Notes-Protected-Question/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Notes-Protected-Question/","excerpt":"前言：在查询关于 Java 数据域绑定问题的时候，意外看到一篇关于访问修饰符 protected 的文章，感觉受益颇多，纠正了自己以前对于 protected 的&quot;误解&quot;，特此记录一下自己的验证过程及自己的理解。","text":"前言：在查询关于 Java 数据域绑定问题的时候，意外看到一篇关于访问修饰符 protected 的文章，感觉受益颇多，纠正了自己以前对于 protected 的&quot;误解&quot;，特此记录一下自己的验证过程及自己的理解。 主要内容 强烈建议阅读此文章 下面说说我自己的理解，首先有两个要素要确定。 调用的方法（假设为 sayHello 方法，并且是 protected 的）来自哪里（我们姑且称之为源类） 由源类确定sayHello方法的可见性（同包 + 子类） 注意： 这里在我看来同包的可见性与子类的可见性是不一样的，下面会结合例子进行说明，力求表述清楚。 Java 中成员变量是静态绑定的，在继承的时候没有动态效果，为更好理解与说明，所以下面的例子全部以方法为主。 例子 以最普通的一个例子开头，在包 access.access1 下有如下 Person 类 package access.access1; public class Person { protected void sayHello() { System.out.println(\"Person.sayHello\"); } } 由上可知：sayHello 方法的可见范围为 access1 包及Person的子类 先试试同包的情况： package access.access1; public class CallObject { public static void main(String[] args) { Person p = new Person(); p.sayHello(); } } 结果：不出意外，一切正常，编译通过。 再试子类（不同包）：在包 access.access2 下有如下 Man 类 package access.access2; import access.access1.Person; public class Man extends Person { public static void main(String[] args) { Person p = new Person(); p.sayHello(); // Error } } 结果：嗯。。。出错了，说好的可见呢? 再试试？ package access.access2; import access.access1.Person; public class Man extends Person { public static void main(String[] args) { Man man = new Man(); man.sayHello(); } } 结果：成功运行。证明了一点，protected 对于子类与同包的可见性是不一样的。 包：可调用 子类：可获得 + static？ 在把 Person 类的 sayHello 方法标成 static 后，上面的三个例子均通过，具体原因以后再探索吧。 小结 在面对 protected 方法时，首先看它来自哪里，再看它在哪里调用（子类还是同包）。 子类实例无法调用父类实例的 protected 方法。（父类：我可以搞一份给你，但你不能拿我的）","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.kbrx93.com/tags/Java/"},{"name":"杂记","slug":"杂记","permalink":"https://hexo.kbrx93.com/tags/杂记/"},{"name":"protected","slug":"protected","permalink":"https://hexo.kbrx93.com/tags/protected/"},{"name":"访问修饰符","slug":"访问修饰符","permalink":"https://hexo.kbrx93.com/tags/访问修饰符/"}]},{"title":"Java杂记（六）内部类与序列化结合之后的坑","slug":"2018-04-06Java杂记（六）内部类与序列化结合之后的坑","date":"2018-04-05T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Notes-InnerClass-Serializable/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Notes-InnerClass-Serializable/","excerpt":"前言：在一个技术公众号看到内部类与序列化结合之后的坑，感觉值得研究一下。","text":"前言：在一个技术公众号看到内部类与序列化结合之后的坑，感觉值得研究一下。 主要内容 一切的起因都是这个非常简单的例子 public class Out { class Inner implements Serializable { public int a; } public static void main(String[] args) { Out out = new Out(); Out.Inner inner = out.new Inner(); try { ObjectOutputStream outputStream = new ObjectOutputStream( new FileOutputStream(\"/Users/kbrx93/Downloads/Inner.ser\")); outputStream.writeObject(inner); } catch (IOException e) { e.printStackTrace(); } } } 就是一个内部类的序列化，运行结果如下： 提示说Out类无法序列化（其实这里就可以看出点东西），反编译一下Out$Inner.class看看，结果如下： class Out$Inner implements Serializable { public int a; final Out this$0; Out$Inner() { this.this$0 = Out.this; super(); } } 可以很清楚地看到，编译器给我们的内部类生成了一个外部类的引用，并生成一个构造函数来初始化，这也是为什么内部类可以访问外部类所以成员变量的原因。 从Java的文档我们也可以找到解释： If the constructor’s declaring class is an inner class in a non-static context, the first argument to the constructor needs to be the enclosing instance; see The Java Language Specification, section 15.9.3 而上面出错的原因也就浮现出来了，一个类要序列要具备有两个条件 实现Serializable接口（可以是另一个接口，另外写篇序列化的文章扩展） 类中所有的成员变量都要可序列化，如果变量是类引用的话，则对应的类须实现Serializable接口 + static？ 上面的问题也基本解决了，那换一个角度，如何解决？ Out实现Serializable接口 Inner类变为静态类，把Out类的引用去掉。 关于静态与序列化的关系，还要注意静态变量是不能被序列化的，更具体的另开一篇关于序列化的。 小结 如果可以，最好不要使用内部类 + 序列化的组合","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.kbrx93.com/tags/Java/"},{"name":"杂记","slug":"杂记","permalink":"https://hexo.kbrx93.com/tags/杂记/"},{"name":"内部类","slug":"内部类","permalink":"https://hexo.kbrx93.com/tags/内部类/"},{"name":"序列化","slug":"序列化","permalink":"https://hexo.kbrx93.com/tags/序列化/"}]},{"title":"Java杂记（五）代码层面及字节码层面的特征签名区别","slug":"2018-04-05Java杂记（五）代码层面及字节码层面的特征签名区别","date":"2018-04-04T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Notes-signature-different/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Notes-signature-different/","excerpt":"前言：在读《深入理解Java虚拟机》一书时发现一个有趣的点：方法的特征签名有可能与返回值有关？？","text":"前言：在读《深入理解Java虚拟机》一书时发现一个有趣的点：方法的特征签名有可能与返回值有关？？ 主要内容 书中给了这样的两个例子： public class Signature { public void s(List&lt;String&gt; list) { System.out.println(\"Signature.s1\"); } public void s(List&lt;Integer&gt; list) { System.out.println(\"Signature.s2\"); } } 很明显，上面的例子是不能通过编译的，因为Java的泛型只是一种伪泛型，在编译时就被擦除了，所以上面的两个方法在编译器眼中特征签名是一样的（方法名 + 参数类型 + 参数顺序） 接着书中有给了如下的例子，说是可以通过编译运行的 因为Java代码规范中方法特征签名为 方法名 + 参数类型 + 参数顺序，而在JVM规范中class字节码的方法特征签名为 方法名 + 参数类型 + 参数顺序 + 返回值类型 + 异常参数，还有这种操作？？ public class Signature { public String s(List&lt;String&gt; list) { System.out.println(\"Signature.s1\"); return \"\"; } public int s(List&lt;Integer&gt; list) { System.out.println(\"Signature.s2\"); return 1; } } 结果我实际编译一下，还是不能通过编译，我心想：书错了？？ 仔细一看，是需要Java1.6的Javac编译器，而我是1.8的，所以不能通过（编译器改了，Jvm没改）。下图为1.8的Java虚拟机规范 改用1.6编译一下，得到的class文件在1.8上可以正常运行，证明了书上的观点 总结一下 Java代码规范中方法特征签名为 方法名 + 参数类型 + 参数顺序，而在JVM规范中class字节码的方法特征签名为 方法名 + 参数类型 + 参数顺序 + 返回值类型 + 异常参数，需要1.6的Javac编译器","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.kbrx93.com/tags/Java/"},{"name":"区别","slug":"区别","permalink":"https://hexo.kbrx93.com/tags/区别/"},{"name":"杂记","slug":"杂记","permalink":"https://hexo.kbrx93.com/tags/杂记/"},{"name":"特征签名","slug":"特征签名","permalink":"https://hexo.kbrx93.com/tags/特征签名/"}]},{"title":"Java杂记（四）赋值与自增运算的一道简单思考题","slug":"2018-04-04Java杂记（四）赋值与自增运算的一道简单思考题","date":"2018-04-03T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Notes-Assignment-Increment/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Notes-Assignment-Increment/","excerpt":"前言：在牛客上做题，看到一道题 输出为0，本来以为是1，出错了，所以想稍微研究一下","text":"前言：在牛客上做题，看到一道题 输出为0，本来以为是1，出错了，所以想稍微研究一下 主要过程 主要就是几个方法，用Javap反编译一下，看看到底有什么妖魔鬼怪 先解释一下 操作栈索引从1开始，局部变量表从0开始，但由于是非静态，所以第0个为this引用 iconst_1：将常量1压入操作栈 istore_1：将操作栈栈顶元素弹出，写入局部变量表为1的位置 iload_1：将局部变量表索引为1的元素压入栈顶 iadd：将栈内的前两个元素相加，结果压入栈顶 iinc 1, 1：将局部变量表索引为1的值增加1（没有经过栈） 示例代码 public class Test { /** * Code: * stack=2, locals=2, args_size=1 * 0: iconst_1 * 1: istore_1 * 2: iload_1 * 3: iconst_1 * 4: iadd * 5: istore_1 * 6: return */ public void test4() { int i = 1; i = i + 1; } /** * Code: * stack=1, locals=2, args_size=1 * 0: iconst_1 * 1: istore_1 * 2: iinc 1, 1 * 5: return */ public void test3() { int i = 1; i++; } /** * Code: * stack=1, locals=2, args_size=1 * 0: iconst_1 * 1: istore_1 * 2: iload_1 * 3: iinc 1, 1 * 6: istore_1 * 7: return */ public void test() { int i = 1; i = i++; } /** * Code: * stack=2, locals=2, args_size=1 * 0: iconst_1 * 1: istore_1 * 2: iload_1 * 3: iconst_1 * 4: iadd * 5: istore_1 * 6: iload_1 * 7: istore_1 * 8: return */ public void test1() { int i = 1; i = i + 1; i = i; } /** * Code: * stack=2, locals=2, args_size=1 * 0: iconst_1 * 1: istore_1 * 2: iload_1 * 3: istore_1 * 4: iload_1 * 5: iconst_1 * 6: iadd * 7: istore_1 * 8: return */ public void test12() { int i = 1; i = i; i = i + 1; } } 其实从上面的例子分析就可以知道： 遇到运算（赋值右部分），是常量先压入栈，不是常量从局部变量表压入，然后在栈中进行相关操作（在这里是+），结果压入栈顶 接着进行赋值运算，将栈顶的运算结果用iload_*来写入局部变量表 所以上面的题目最大的问题用了i++，i = i ++这句话遇到的时候先把i（0）压入栈，然后i++这家伙直接在局部变量表自增1，接着又遇到赋值，直接把栈中保存的0拉了过来，覆盖掉了i++的成果。。","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.kbrx93.com/tags/Java/"},{"name":"杂记","slug":"杂记","permalink":"https://hexo.kbrx93.com/tags/杂记/"},{"name":"赋值","slug":"赋值","permalink":"https://hexo.kbrx93.com/tags/赋值/"},{"name":"自动","slug":"自动","permalink":"https://hexo.kbrx93.com/tags/自动/"},{"name":"局部变量表","slug":"局部变量表","permalink":"https://hexo.kbrx93.com/tags/局部变量表/"},{"name":"操作栈","slug":"操作栈","permalink":"https://hexo.kbrx93.com/tags/操作栈/"}]},{"title":"Java杂记（三）ArrayList自动扩容的一道面试题","slug":"2018-04-04Java杂记（三）ArrayList自动扩容的一道面试题","date":"2018-04-03T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Notes-ArrayList-Automatic-expansion/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Notes-ArrayList-Automatic-expansion/","excerpt":"前言：在一个微信群中看到一道关于阿里ArrayList自动扩容的题，感觉自己以前的认知出现了偏差，特此记录下。","text":"前言：在一个微信群中看到一道关于阿里ArrayList自动扩容的题，感觉自己以前的认知出现了偏差，特此记录下。 主要过程 题目：总内存为150M，已有ArrayList占100M，此时ArrayList要自动扩容，怎么办？ 答案：要扩就扩呗。 解析 这道本身就是一个陷阱，我们由源码可以知道，ArrayList要扩容时要先新建一个现在容量的1.5倍的新对象数组 然后再调用Arrays.copy（本质上是调用System.arraycopy）复制过去 好了，我的疑问出现了，要新建一个150M的对象数组，但是只有50M了，怎么办？？，又不能序列化到磁盘，太慢了 在调试过程中我发现，上面这个疑问是多么地愚蠢。。 关键在于对T[] copy = new Object[newLength]这句理解不够透彻，这句话干了什么，生成了若干个null的引用啊。 也就是说，对象数组只有在实际增加（也就是put的时候）的时候才会占用内存（就是新买的钱包里没有钱一个道理） 打完，收工。","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.kbrx93.com/tags/Java/"},{"name":"杂记","slug":"杂记","permalink":"https://hexo.kbrx93.com/tags/杂记/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://hexo.kbrx93.com/tags/ArrayList/"},{"name":"自动扩容","slug":"自动扩容","permalink":"https://hexo.kbrx93.com/tags/自动扩容/"},{"name":"面试题","slug":"面试题","permalink":"https://hexo.kbrx93.com/tags/面试题/"}]},{"title":"Java杂记（二）自动装箱的一个题","slug":"2018-04-04Java杂记（二）自动装箱的一个题","date":"2018-04-02T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Notes-autobox-topic/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Notes-autobox-topic/","excerpt":"前言：在《深入理解Java虚拟机》一书中看到一个关于AutoBox的题，实测了一下，结果与自己估计的不太一样，于是写一写记录一下过程。","text":"前言：在《深入理解Java虚拟机》一书中看到一个关于AutoBox的题，实测了一下，结果与自己估计的不太一样，于是写一写记录一下过程。 主要过程 题目 运行结果 分析 关于第一个和第二个没有什么大问题，不过是一个Integer对象的-128～127的缓存数组问题，但问题出在3，5，6上，怎么会是相反的结果呢？ 用Jad反编译一下，看看到底是怎运行的。 一目了然，问题的关键有三个 遇到算术运算时会自动拆箱 equals的时候会自动装箱 equals不会处理数据转型问题（即Long.equals(Integer)为False的例子） （不是关键）还有一个小点是那个自动类型提升","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.kbrx93.com/tags/Java/"},{"name":"杂记","slug":"杂记","permalink":"https://hexo.kbrx93.com/tags/杂记/"},{"name":"自动装箱","slug":"自动装箱","permalink":"https://hexo.kbrx93.com/tags/自动装箱/"},{"name":"equals","slug":"equals","permalink":"https://hexo.kbrx93.com/tags/equals/"}]},{"title":"Java杂记（一）构造块、构造函数执行顺序","slug":"2018-04-03Java杂记（一）构造块、构造函数执行顺序","date":"2018-04-02T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Notes-constructer-init/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Notes-constructer-init/","excerpt":"前言：在牛客上做了几道关于静态块、静态语句、构造块、构造函数 + 继承 的执行顺序，觉得理解得还是不够明白，自己写了个比较复杂的例子，搞懂这个就不成问题了。","text":"前言：在牛客上做了几道关于静态块、静态语句、构造块、构造函数 + 继承 的执行顺序，觉得理解得还是不够明白，自己写了个比较复杂的例子，搞懂这个就不成问题了。 主要内容 例子 class SuperClass { static SuperClass A = new SuperClass(); static { System.out.println(\"B\"); } { System.out.println(\"C\"); } public SuperClass() { System.out.println(\"D\"); } } class SubClass extends SuperClass { static SubClass B = new SubClass(); static { System.out.println(\"E\"); } { System.out.println(\"F\"); } public SubClass() { System.out.println(\"G\"); } public static void main(String[] args) { new SubClass(); } } 结果 解释 明确执行的规则：静态块/静态成员变量 &gt; Main方法 &gt; 构造块 &gt; 构造函数 不同的静态块/静态成员变量按照出现的顺序执行，且只执行一次，因为它是属于类的，不是属于实例对象的，而类只加载一次。 构造块和构造函数则是new几次就执行几次 new 子类会先执行父类的构造块和构造函数 这里有疑问可以在于执行static SuperClass A = new SuperClass();这里一句时为什么不会将后面的静态代码块执行，还是那个原因，静态的东西是属于类的，不是实例，因此属于new SuperClass();的时候并不会对后面的静态有什么非分之想。","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.kbrx93.com/tags/Java/"},{"name":"杂记","slug":"杂记","permalink":"https://hexo.kbrx93.com/tags/杂记/"},{"name":"执行顺序","slug":"执行顺序","permalink":"https://hexo.kbrx93.com/tags/执行顺序/"}]},{"title":"数据结构（一）树","slug":"2018-03-31数据结构（一）树","date":"2018-03-30T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Data-Structure-Tree /","link":"","permalink":"https://hexo.kbrx93.com/tech/Data-Structure-Tree /","excerpt":"前言：简单记录一下对树的学习过程及发现","text":"前言：简单记录一下对树的学习过程及发现 什么是树？ 有限结点组合而成的层次结构集合 树当中的一些基本概念： 结点度 度（max结点度） 深度：层数 左右可否交换：有序树、无序树 森林 二叉树的定义： 结点度 &lt;= 2 有序树 二叉树的性质（很多，具体Google） 结点数 - 1 = 边数 第 i 层结点数最多2i−12^{i-1}2i−1 i层数总结点数最多2i−12^i-12i−1 如果是完全二叉树：有n个结点，深度为log2n+1log_2n+1log2​n+1 树的实现 顺序存储 链式存储 树的分类及作用 作用很多，Google，下面是比较重点的树，需知 定义 作用（具体应用场景、为什么使用） 转化调整过程 如何实现 AVL（旋转调整） RBT（旋转着色过程，最坏3次旋转） B树（多路平衡查找） B+树（1/2、具体数据在叶子结点指针链表中） B*树（2/3、兄弟结点指点）","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://hexo.kbrx93.com/tags/数据结构/"},{"name":"树","slug":"树","permalink":"https://hexo.kbrx93.com/tags/树/"}]},{"title":"Java基础（三）GC","slug":"2018-03-24Java基础（三）GC","date":"2018-03-23T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Basis-GC/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Basis-GC/","excerpt":"前言：主要记录了在学习JVM过程中对于GC的理解。 PS: 由于最近需要准备的东西比较多，如果单纯总结性写的话花的时间还少点，但大多数知识点是边学边记录，由此花费的时间十分地多，但自己又想写。。。所以只能是记录下思路和自己的发现，以后有时间再&quot;丰满血肉&quot;吧。。","text":"前言：主要记录了在学习JVM过程中对于GC的理解。 PS: 由于最近需要准备的东西比较多，如果单纯总结性写的话花的时间还少点，但大多数知识点是边学边记录，由此花费的时间十分地多，但自己又想写。。。所以只能是记录下思路和自己的发现，以后有时间再&quot;丰满血肉&quot;吧。。 GC指JVM自动回收内存的过程。强调，是在堆上。。 主要从三个方面理解GC： 审判 JVM如何判定一个对象是无用的？ 缓刑 无用的对象最后的自救？ 执行 JVM如何回收已确定需要处理的对象？ 每一个过程又分为理论与实际实现细节。 理论 审判 引用计数（循环引用问题） 可达性分析 什么是引用？Java中有哪些引用（JDK1.7之后引入强引用之外的三种） 强引用（正常对象引用，存在则GC绝不会回收？真的吗） 软引用（内存不够时回收掉） 弱引用（内存够不够时下次GC都回收掉） 虚引用（没什么用，只是GC掉时通知一下存有该引用的对象） 缓刑 finalize方法 只能执行一次 只能由GC执行时才有特殊功效 可以在这个方法中&quot;自救&quot; 整个finalize的过程，如F-Queue、F-unreadable状态 执行 简单来说：GC算法 复制回收 标记清除 标记整理 实际实现细节 审判 什么对象可以作GC Root（简单来说，就是活跃引用） 如何安全地进入可达性 Safe Point 以HotSpot VM为具体例子看题主的代码例子。HotSpot VM里，解释执行的方法可以在任意字节码边界上进入GC，但JIT编译后的代码并不能在“任意位置”进入GC。可以进入GC的“特定位置”叫做“GC safepoint”，或者简称“safepoint”。这段 Java 代码中的局部变量能够被提前回收吗？编译器或 VM 能够实现如下的人工优化吗？ OopMap Safe Region 执行 简单来说：GC回收器 深入理解JVM(3)——7种垃圾收集器 补充 为什么GC要分代 之前不能并行的时候，防止STW时间太长让用户不爽 现在可以大部分并行的时候，是为了提高GC回收内存的速率 GC的触发 Major GC和Full GC的区别是什么？触发条件呢？","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.kbrx93.com/tags/Java/"},{"name":"基础","slug":"基础","permalink":"https://hexo.kbrx93.com/tags/基础/"},{"name":"GC","slug":"GC","permalink":"https://hexo.kbrx93.com/tags/GC/"}]},{"title":"Java基础（二）Java内存模型","slug":"2018-03-21Java基础(二)Java内存模型","date":"2018-03-20T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Basis-JMM-learning/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Basis-JMM-learning/","excerpt":"前言：在学习Java内存模型（Java Memory Model, 简称JMM）过程中的记录。","text":"前言：在学习Java内存模型（Java Memory Model, 简称JMM）过程中的记录。 强烈建议看 PDF: 深入理解 Java 内存模型_程晓明_InfoQ 作为补充：Java 并发编程(1): Java 内存模型(JMM) 并发 为了进入JMM的世界，首先来了解一下并发的概念： 并发意味着多个执行实体可能需要竞争资源 在操作系统中，执行实体是线程，也就是，在高级语言程序设计中，并发编程就是如何处理线程间的关于有限资源的竞争问题。 问：有竞争，如何解决？ 答：这里的&quot;解决&quot;涉及并发编程模型中两个关键的问题：通信（tell）与同步（order），更多可以看这里深入理解Java内存模型（一）——基础 通信 同步 消息通信 显式 隐式 共享内存（Java） 隐式 显式 简单来说就得到了上面的这个表格关系。 问：Java采用共享内存的方式来应对并发，那对内存具体的逻辑划分是怎样的？ 答：这就涉及到了Java的内存模型——JMM，关于JMM的历史，JSR-133等可以参考上面的文章，也可自行搜索。 简单来说，从有什么用的角度出发，JMM对（谁？）在堆中被共享的实例数据、静态域、数组元素等进行（什么操作？）合法交互及写入可见的控制。 合法交互 具体指JMM规定了在内存多个线程如何进行通信 写入可见 一条线程对变量的写入何时对其它线程可见 （关于JVM的内存结构划分可以参考这篇文章 jvm系列(二):JVM内存结构） 从性质方面，JMM其实就描述了三个方面：原子性、可见性、有序性 关键概念 关于JMM概念的描述始终想不到一条合理的逻辑线来串起来（能力有限。。），只能以一些比较常见且重要的概念零散地列出来。 可以理解为JMM如何围绕 原子性、可见性、有序性 来引入相关概念，同时实现相关的功能。 交互操作 在JMM中，关于主内存与工作内存之间具体的同步交互细节，明确了8种操作，并且强制这8种操作一定是原子性的（在操作 long 与 double 例外，详请可以Google 非原子性协议） lock unlock read load use assign store write 重排序 重排序是指编译器或CPU等在不改变程序运行结果（注意是单线程）的情况下对语句或指令的顺序进行调整，从而获得更好的执行效率。 更多：Java内存访问重排序的研究 顺序一致性 一个线程中的所有操作必须按照程序的顺序来执行。（顺序） （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。（单一顺序、立即可见） 更多： 深入理解Java内存模型（三）——顺序一致性 扩展：为什么程序员需要关心顺序一致性（Sequential Consistency）而不是Cache一致性（Cache Coherence？） 同步 多个线程的操作通过一定的机制进行协调，从而使多个线程都正确地执行程序，即得到的结果与顺序一致性模型得到的结果一致。 内存屏障 内存屏障（Memory Barrier，或有时叫做内存栅栏，Memory Fence）是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。 更多：同重排序文章 Java内存访问重排序的研究 关键字 上面介绍了8种对变量的原子操作，Java也提供了关键字来让保证程序的可见性、原子性、有序性 volatile volatile关键字有两个作用： 保证变量值同步（可见性） 禁止指令重排序（有序性） 注意volatile关键字并没有保证原子性，所以不能保证同步 更多： Java 并发编程：volatile的使用及其原理 正确使用 Volatile 变量 volatile的应用场景 聊聊并发（一）——深入分析Volatile的实现原理 synchronize synchronize修饰的变量或代码：互斥与可见 其中互斥即保证了有序性，也保证了原子性 更多：Java中Synchronized的用法 扩展： 深入理解多线程（一）——Synchronized的实现原理 深入理解多线程（二）—— Java的对象模型 深入理解多线程（三）—— Java的对象头 深入理解多线程（四）—— Moniter的实现原理 final final声明的变量如果在构造阶段不发生this引用逃逸的话具有可见性 更多： 深入理解Java内存模型（六）——final 关于final重排序的问题？ happen-before happen-before其实就是JMM为开发者提供的一些默认有序规则，用来维护代码的有序性，而不用仅靠volatile或synchronized 更多： 【Java并发编程】之十六：深入Java内存模型——happen-before规则及其对DCL的分析（含代码）","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.kbrx93.com/tags/Java/"},{"name":"基础","slug":"基础","permalink":"https://hexo.kbrx93.com/tags/基础/"},{"name":"JMM","slug":"JMM","permalink":"https://hexo.kbrx93.com/tags/JMM/"},{"name":"内存模型","slug":"内存模型","permalink":"https://hexo.kbrx93.com/tags/内存模型/"},{"name":"可见性","slug":"可见性","permalink":"https://hexo.kbrx93.com/tags/可见性/"},{"name":"并发","slug":"并发","permalink":"https://hexo.kbrx93.com/tags/并发/"}]},{"title":"Java基础（一）final & finally & finalize","slug":"2018-03-16Java基础（一）final & finally & finalize","date":"2018-03-16T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java-Basis-final-finally-finalize/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java-Basis-final-finally-finalize/","excerpt":"前言：对final、finally、及finalize三个Java概念进行区别。（由于网上的资料非常多，可能只是列一些关键及在查找过程中发现的相关联的知识点，并提供一些值得参考的文章）","text":"前言：对final、finally、及finalize三个Java概念进行区别。（由于网上的资料非常多，可能只是列一些关键及在查找过程中发现的相关联的知识点，并提供一些值得参考的文章） final Java关键字、“不可改变” 作用 在类上：不能被继承或重写 在方法上：不能被重写 在成员变量上：在使用中不能被改变 final变量初始化时机： final变量定义时 构造函数 文章 final -&gt; 内联 -&gt; 类层次分析 -&gt; 虚方法 -&gt; 接口变量与final -&gt; 匿名内部类与final -&gt; private 与final 深入理解Java中的final关键字 Final of Java，这一篇差不多了 这篇更底层，值得一看 上面的文章中有几点我个人觉得需要注意或补充，如下 文中提到在方法上用final关键字可以使编译器编译的时候转入内联或内嵌模式，会提高效率，这一点也在《Think in Java》一书中提及。 但是，请注意是在早期的时候，在现代的Java编译器中，可以通过CHA（Class Hierarchy Analysis 类层次分析）来智能地判断一个方法是否可以进行内联，从而进行接下来的操作，并不一定需要final的&quot;提示&quot;，也就是final在现代的编译器中和提高效率没有直接联系 上面提到了内联及类层次分析的概念，先说内联，其本质就是copy public void A { B(); } public final void B { balabala } 上面的代码编译器在调用A的时候，发现调用了B，所以本来是要进行一系列压栈、保存现场、弹栈等一系列的操作（因为Java中的动态绑定，只有到了运行期，才知道实际调用的方法），但是它发现B是个final的[手动滑稽]，所以它知道这个家伙是个倔脾气，谁也不能改变它，所以它就直接把B的代码copy到了A中调用B的地方（代码展开，静态绑定），接着顺序运行代码了，这样的效率要比正常的方法调用高。 关于内联内容，可以看看final修饰递归方法会提高效率吗？ 类层次分析，一种对类的关系进行分析的方法（废话），前面说了，通过类层次分析可以在编译时对方法进行智能的分析，从而决定是否能进行内联，与final无关。具体过程如下（引用自java中final的作用）： 编译器在进行内联时, 如果是非虚方法, 那么直接进行内联 如果遇到虚方法(使用invokevirtual进行调用), 则java通过引入&quot;类型继承关系分析&quot;(Class Hierarchy Analysis, CHA), CHA查询此方法在当前程序下是否有多个目标版本可供选择 如果查询结果只有一个版本, 则可以进行内联, 称为守护内联 如果CHA查询得到多个版本的目标方法, 则编译器会使用内联缓存来完成方法内联: 在未发生方法调用之前, 内联缓存状态为空, 当第一次调用发生后, 缓存记录下方法接收者的版本信息, 并且每次进行方法调用的时候都比较接收者版本, 如果以后进来的每次调用的方法接收者版本都一样则继续使用内联, 如果发生变化, 则说明程序使用了虚方法的多态特性, 则会取消内联, 查找虚方法进行方法的分派。 接口变量与final interface A{ int i = 0; //i 默认是public static final } 这里可理解成接口本身就相当于一个模板，所以模板内的东西一定是可见并且不可变的 在匿名类中所有变量都必须是final变量 这句更准确的表达是匿名内部类来自外部闭包环境的自由变量必须是final的，关于这个问题，记住一个点：变量同步，即为了局部变量与在内部类建立的拷贝副本保持一致。 具体参考： java为什么匿名内部类的参数引用时final？ private 与final 两者功能上有重叠部分（不可被子类见自然不可重写），所以写在一起没有问题，但是一般不这么写 finally 异常处理 finally其实就是执行时机及各式各样的return这两个问题 文章 关于 Java 中 finally 语句块的深度辨析 这篇文章深度是有的，但是Demo举的不是很好 Java finally语句到底是在return之前还是之后执行？ 对比上一篇，这篇文章更好懂，同时，针对值传递与引用传递，文中说得不是很清楚，在下面的评论有十分易懂的解释。截图如下： 可以理解成，你在try中的返回之前，会有一个变量（不管是值还是引用）的备份，你在finally中的所有操作都只是操作原来的变量，当操作完成后返回try中的return时会被备份覆盖，而区别只是引用类型你在finally可以操作它指向的对象，并没有改动引用本身（还是指向原来的那个对象），所以你对它指向的对象的操作自然不会被覆盖掉。 基本上搞定上面两篇，finally的基本问题就搞懂了（当然还可以再深入） finalize java finalize方法 finalize方法不一定会执行，只能保证如果重写了finalize，则GC时一定会执行该方法（JVM没有意外退出） System.gc()只是加快gc调用，也并一定会执行GC 关键是对象销毁过程要理解 java finalize方法总结、GC执行finalize的过程 可以结合第一篇的对象销毁过程一起理解 JVM的垃圾回收机制详解和调优 finalize抛出的未捕获异常只会导致该对象的finalize执行退出 用户可以自己调用对象的finalize方法，但是这种调用是正常的方法调用，和对象的销毁过程无关 JVM在GC的时候如果发现对象有finalize方法，一定会去执行，但如果finalize方法是空的话，它会&quot;视而不见&quot;，也就是说直接Reclaimed，不会放入F-Queue 详解java垃圾回收机制(转)及finalize方法（转） 这篇更多的是GC的知识，可以配合《深入理解Java虚拟机》来Enjoy Java 对象释放与 finalize 方法 发生 GC 时一个对象的内存是否释放取决于是否存在该对象的引用，如果该对象包含对象成员，那对象成员也遵循本条 对象里包含的对象成员按声明顺序进行释放","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.kbrx93.com/tags/Java/"},{"name":"基础","slug":"基础","permalink":"https://hexo.kbrx93.com/tags/基础/"},{"name":"区别","slug":"区别","permalink":"https://hexo.kbrx93.com/tags/区别/"},{"name":"final","slug":"final","permalink":"https://hexo.kbrx93.com/tags/final/"},{"name":"finally","slug":"finally","permalink":"https://hexo.kbrx93.com/tags/finally/"},{"name":"finalize","slug":"finalize","permalink":"https://hexo.kbrx93.com/tags/finalize/"}]},{"title":"Mac上由锐捷转CoCoaMento的过程记录","slug":"2018-03-09Mac上锐捷转CoCoa Mento的过程记录","date":"2018-03-08T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"other/ruijie-to-cocoamento/","link":"","permalink":"https://hexo.kbrx93.com/other/ruijie-to-cocoamento/","excerpt":"前言：本来在Mac上用着锐捷客户端用得好好的，也不用折腾。但是前几天下载了一个Paralles Destop，锐捷也如约体现出它的坑爹性质——与多网卡冲突，同时也是早就受够了每次开机都要输入密码，所以综合之后决定使用Cocoa Mento开始了小小的折腾。","text":"前言：本来在Mac上用着锐捷客户端用得好好的，也不用折腾。但是前几天下载了一个Paralles Destop，锐捷也如约体现出它的坑爹性质——与多网卡冲突，同时也是早就受够了每次开机都要输入密码，所以综合之后决定使用Cocoa Mento开始了小小的折腾。 准备 Cocoa Mento startupizer 2 (用来管理开机项，后面会提及) 主要过程 Cocoa Mento的安装及配置 Cocoa Mento下载dmg包后把软件拖出，不要直接双击，这样会出现无法更改配置文件的错误 网上有资料说需要更换Cocoa Mento中的8021X.exe, 我这里测试的时候是不用，如有需要，自行测试 认证成功但无法联网问题解决 本来经过上面的配置，把Cocoa Mento加入开机启动项即可，但是再次开机之后却发现无法联网，打开Cocoa Mento的日志发现认证已经成功了，经过多次测试，终于发现是子网掩码错误导致无法联网，由于是采用DHCP方式获取IP，所以无法只静态修改子网掩码（我不会。。），后来发现，点击一下网络设置-高级中的DHCP续借重新获得IP与子网掩码即可。 开机运行问题 经过上面的操作，基本的使用已经没有问题了，但是。。。。每次开机都需要这样点一下。。很烦，所以接着搞开机启动，第一时间想到了万能的SHELL，在网上查资料，找到在刷新DHCP的命令为sudo ipconfig set en0 DHCP，由于需要sudo，所以开机还要输入密码，直接写一个脚本执行命令并输入密码（密码明文，不是一个好习惯。。不管了），再用startupizer 2延时启动脚本，搞定。 #!/usr/bin/expect spawn sudo ipconfig set en0 DHCP expect \"Password:\" send \"你的密码\\r\" interact exec zsh 如果不加最后的exec zsh，我这里是会报错，不知道为什么。。 参考 How to Renew a DHCP Lease in Mac OS X","categories":[{"name":"other","slug":"other","permalink":"https://hexo.kbrx93.com/categories/other/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://hexo.kbrx93.com/tags/mac/"},{"name":"锐捷","slug":"锐捷","permalink":"https://hexo.kbrx93.com/tags/锐捷/"},{"name":"联网","slug":"联网","permalink":"https://hexo.kbrx93.com/tags/联网/"},{"name":"启动项","slug":"启动项","permalink":"https://hexo.kbrx93.com/tags/启动项/"}]},{"title":"Spring事务简单了解","slug":"2018-02-07Spring事务","date":"2018-02-06T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Spring-transaction-study/","link":"","permalink":"https://hexo.kbrx93.com/tech/Spring-transaction-study/","excerpt":"前言: 对于事务的一些基本认识,同时通过一个转账业务来认识Spring中对于事务的具体实现方式。","text":"前言: 对于事务的一些基本认识,同时通过一个转账业务来认识Spring中对于事务的具体实现方式。 事务了解 对事务的一个基本的了解 事务及其基本属性 事务的ACID： atomicity 原子性 consistency 一致性（老大） isolation 独立性 durability 持久性 并发问题 主要指事务在并发的情况下会出现的问题，主要有三种： 脏读：一个事务还未提交，另外一个事务访问此事务修改的数据，并使用，读取了事务中间状态数据。 不可重复读：一个事务读取同一条记录2次，得到的结果不一致，由于在2次读取之间另外一个事务对此行数据进行了修改。 幻读：一个事务读取2次，得到的记录条数不一致，由于2次读取之间另外一个事务对数据进行了增删。 事务的隔离级别 隔离级别即指采用何种策略来控制锁的程度。 主要有四种： 事务隔离级别 存在的问题 Read Uncommitted 脏读、不可重复读、幻读 Read Committed 脏读、不可重复读、幻读 Repeatable Read 脏读、不可重复读、幻读 Serializable 脏读、不可重复读、幻读 事务的传播行为 针对两个都有事务的A和B（都是有身份的人），当A调用B（打call？？）时，事务应该如何处理 当前 指原先调用方法的一方 事务级别 相关描述 理解 Required 支持当前事务，若当前不存在事务，则创建一个新事务。这是 Spring 使用的默认方式。 我要有一个事务 Supports 支持当前事务，若当前不存在事务，则以非事务方式执行。 很随意，有就有，没有就没有 Mandatory 支持当前事务， 若当前不存在事务，则抛出异常。 老子一定要有事务 Requires New 创建一个新事务，若当前存在事务，则挂起当前事务。 我要有一个新的事务 Not Supported 以非事务方式执行， 若当前存在事务，则挂起当前事务。 我不要有，要我也挂起来 Never 以非事务方式执行， 若当前存在事务，则抛出异常。 绝对绝对不要 Nested 创建一个新事务， 若当前存在事务，则将新创建的事务作为“子事务”，与已有事务构成父子关系。 有就是我儿子 Spring中的事务管理 记录Spring中对于事务的管理的API及如何编写相关代码（两种方式） 整个转账Project查看 Spring中关于事务的核心API Spring中对事务的管理核心API主要有三个 PlatformTransactionManager 事务管理器，事务的主要执行者 TransactionDefinition 事务管理五个属性： 传播行为 隔离级别 是否只读 超时时间 回滚规则 TransactionStatus 提供控制事务执行和查询事务状态的方法 事务管理器PlatformTransactionManager从TransactionDefinition中获得事务的初始定义并开始执行，并将其状态保存到TransactionStatus中 编程式事务管理 以下的实例(编程式及声明式)都省略导入Jar包的步骤, 具体查看项目中build.gradle中依赖 步骤： 配置事务管理器 &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; 配置事务模板对象 &lt;!-- 配置事务模板 --&gt; &lt;bean id=\"transactionTemplate\" class=\"org.springframework.transaction.support.TransactionTemplate\"&gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt; &lt;/bean&gt; 将事务模板对象注入到Service对象中，并进行使用（侵入） 配置文件中代码： Service层代码： 这种方式对于代码的侵入性比较大，一般比较少使用 声明式事务管理 有三种： 基于TransactionProxyFactoryBean 基于AspectJ的XML方式 基于Spring AOP的注解方式 TransactionProxyFactoryBean 步骤： 配置事务管理器 &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; 配置事务代理对象 &lt;!--配置代理对象--&gt; &lt;bean id=\"serviceProxy\" class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\"&gt; &lt;!-- 注入目标对象 --&gt; &lt;property name=\"target\" ref=\"service\"/&gt; &lt;!-- 注入事务管理器 --&gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\"/&gt; &lt;!-- 注入事务属性 --&gt; &lt;property name=\"transactionAttributes\"&gt; &lt;props&gt; &lt;prop key=\"transfer\"&gt;PROPAGATION_REQUIRED&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;prop&gt;内可选值: propagation 传播行为 isolation 隔离级别 +Exception 设置不回滚的异常 read-only 是否为只读事务 -Exception 设置回滚的异常 这一种方式在使用的时候要注入代理类，而不是目标类，同时实际开发也比较少用，因为针对每一个具体的类都要配置一个代理类，比较繁锁 AspectJ的XML方式 步骤： 配置事务管理器 &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; 配置事务通知及事务切面 &lt;!-- 配置事务通知 --&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"transfer\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置事务切面 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.kbrx93.declarative.aspectj_xml.service.AccountService+.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt; &lt;tx:attributes&gt;标签内可选值: propagation 传播行为 isolation 隔离级别 no-rollback-for 设置不回滚的异常(同上 +Exception) read-only=“false” 是否为只读事务 rollback-for 设置回滚的异常(同上 -Exception) 基于Spring AOP的注解方式 步骤： 配置事务管理器 &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; 开启事务注解驱动 &lt;!-- 开启事务注解驱动 --&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 在对应的类或方法上打上@Transactional 可以通过标签内的值来设置事务的初始状态, 同上 写在最后 了解了一些关于事务的基本理论知识及Spring中对于的事务的管理及实现方式","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://hexo.kbrx93.com/tags/框架/"},{"name":"Spring","slug":"Spring","permalink":"https://hexo.kbrx93.com/tags/Spring/"},{"name":"事务","slug":"事务","permalink":"https://hexo.kbrx93.com/tags/事务/"},{"name":"xml","slug":"xml","permalink":"https://hexo.kbrx93.com/tags/xml/"},{"name":"注解","slug":"注解","permalink":"https://hexo.kbrx93.com/tags/注解/"},{"name":"AspectJ","slug":"AspectJ","permalink":"https://hexo.kbrx93.com/tags/AspectJ/"},{"name":"AOP","slug":"AOP","permalink":"https://hexo.kbrx93.com/tags/AOP/"}]},{"title":"构建工具——Maven_Draft","slug":"2018-02-06Maven_Draft","date":"2018-02-05T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/buildtools-maven-draft/","link":"","permalink":"https://hexo.kbrx93.com/tech/buildtools-maven-draft/","excerpt":"前言：主要是记录在Maven入门过程中的草稿与备忘。","text":"前言：主要是记录在Maven入门过程中的草稿与备忘。 Maven基本构建命令 clean 清除Target目录 compiler 编译项目 test 测试项目代码 package 打包 install 安装jar包到本地仓库 Maven标准目录 |-- pom.xml |-- src | |-- main | | `-- java | | `-- resources | | `-- webapp | | `-- filters | `-- test | | `-- java | | `-- resources | | `-- filters | `-- it | `-- assembly | `-- site `-- LICENSE.txt `-- NOTICE.txt `-- README.txt 自动生成项目目录 archetype:genetype 生命周期 三个大过程不会相互依赖，但每一个过程中的后面的小步骤会依赖前面的步骤，如只执行package命令的话也会进行compiler-&gt;test-&gt;package的过程 Clean（清理） Default（构建） 执行后面的会依次执行前面的 compiler test package install Site 生成、发布站点 setting.xml文件 如修改镜像站、本地仓库地址、JDK默认的版本等 &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.complier.source&gt;1.8&lt;/maven.complier.source&gt; &lt;maven.complier.target&gt;1.8&lt;/maven.complier.target&gt; &lt;maven.complier.complierVersion&gt;1.8&lt;/maven.complier.complierVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 依赖冲突、原则及解决 分别依赖于不同版本的Jar包所导致的冲突问题 Maven在有不同Jar版本时所采用的原则： 短路径优先 路径相同时谁先被解析到用谁的（即在POM.xml中的位置） 排除引入方法，如下图： 聚合与继承 聚合 将多个Maven项目同时进行操作 &lt;packing&gt;pom&lt;/packing&gt; + &lt;module&gt; 继承 &lt;packing&gt;pom&lt;/packing&gt; &lt;dependencyManagement&gt; 子类写&lt;parent&gt;，无需写版本号及Scope，由引入的父POM控制 Tomcat7 Maven插件 &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/plugin&gt; 遇到的一个问题 主要是因为Tomcat Maven 插件中提供的Servlet Jar 与Spring中的Servlet Jar 冲突，将手动引入的Servlet Jar作用域标为provided即可。 其它备忘 设置Maven工程的编码 project.build.sourceencoding 在插件中设置JDK版本 &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"构建工具","slug":"构建工具","permalink":"https://hexo.kbrx93.com/tags/构建工具/"},{"name":"过程记录","slug":"过程记录","permalink":"https://hexo.kbrx93.com/tags/过程记录/"},{"name":"备忘","slug":"备忘","permalink":"https://hexo.kbrx93.com/tags/备忘/"},{"name":"草稿","slug":"草稿","permalink":"https://hexo.kbrx93.com/tags/草稿/"},{"name":"maven","slug":"maven","permalink":"https://hexo.kbrx93.com/tags/maven/"}]},{"title":"构建工具——Gradle_Draft","slug":"2018-02-06Gradle_Draft","date":"2018-02-05T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/buildtools-gradle-draft/","link":"","permalink":"https://hexo.kbrx93.com/tech/buildtools-gradle-draft/","excerpt":"前言：记录了在Gradle入门的过程的草稿及备忘。","text":"前言：记录了在Gradle入门的过程的草稿及备忘。 Gradle的安装 见官网 Groovy 介绍Groovy语言的语法特点 闭包 高效性 第一个Gradle项目 有些目录及文件（如gradle.properties及subDemo模块）是后来加上去，src目录下的目录结构请参考Maven的标准目录结构 理解Project及Task 大概的书写过程及形式 自定义一个任务 如下： //闭包 def createOther = { path - &gt; File dir = new File(path) if (!dir.exists()) { dir.mkdirs() } } // 生成other目录及子目录 task makeOther() { def paths = ['src/main/other', 'src/main/other/WEB-INF'] doFirst { paths.forEach(createOther) } } /**********************************/ //闭包 def createDir = { path - &gt; File dir = new File(path) if (!dir.exists()) { dir.mkdirs() } } // 生成webapp目录及子目录 // 依赖于makeOther task makeWeb() { dependsOn 'makeOther' def paths = ['src/main/webapp', 'src/main/webapp/WEB-INF'] doFirst { paths.forEach(createDir) } } 生命周期 主要是有三个阶段： 初始化 进行项目的初始化（如Project类的创建） 配置 执行配置语句，确定依赖关系 执行 执行动作语句，进行构建 依赖管理 主要有两点：仓库管理及依赖引入 仓库管理 repositories { // 本地仓库 mavenLocal() // 中央仓库 mavenCentral() // 私服 maven { url \"xxxxx\" } } 依赖引入 dependencies { // 两种坐标形式都可以 testCompile group: 'junit', name: 'junit', version: '4.12' compile \"junit:junit:4.12\" } 版本冲突及解决方法 有两种方法来手动解决版本冲突(Groovy默认选取最高版本)： 强制指定全局版本 configurations.all { resolutionStrategy { // 关闭Gradle对版本冲突的默认处理（全部更改为最高版本） failOnVersionConflict() // 指定版本 force \"org.hamcrest:hamcrest-core:1.3\" } } 针对特定的Jar排除传递依赖 dependencies { compile (\"junit:junit:4.12\") { exclude group:\"org.hamcrest\", module:\"hamcrest-core\" } } 多项目构建 公共属性 公共的属性（如group ‘com.kbrx93’ version ‘1.0-SNAPSHOT’）可以写在整个项目的根下的gradle.properties配置文件 子模块相互依赖 可以用compile project(&quot;:subDemo&quot;)的方式引用 allprojects及subprojects 自动化测试 Gradle会自动发现test测试用例并执行相关操作 发布 使用maven-publish插件进行发布 apply plugin: 'maven-publish' //进行源码的打包任务 task sourceJar(type: Jar) { from sourceSets.main.allJava } //插件相关的配置 publishing { publications { maven(MavenPublication) { //指定group/artifact/version信息，可以不填。 //默认使用项目group/name/version作为groupId/artifactId/version groupId project.group artifactId project.name version project.version //如果是war包填写components.web，如果是jar包填写components.java from components.java //配置上传源码 artifact sourceJar { classifier \"sources\" } } } repositories { maven { //上传地址 url = \"xxx\" //用户 credentials { username 'kbrx93' password '123456' } } } }","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"构建工具","slug":"构建工具","permalink":"https://hexo.kbrx93.com/tags/构建工具/"},{"name":"gradle","slug":"gradle","permalink":"https://hexo.kbrx93.com/tags/gradle/"},{"name":"过程记录","slug":"过程记录","permalink":"https://hexo.kbrx93.com/tags/过程记录/"},{"name":"备忘","slug":"备忘","permalink":"https://hexo.kbrx93.com/tags/备忘/"},{"name":"草稿","slug":"草稿","permalink":"https://hexo.kbrx93.com/tags/草稿/"}]},{"title":"SpringMVC执行流程初识","slug":"2018-02-04SpringMVC执行流程初识","date":"2018-02-03T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/SpringMVC-execution/","link":"","permalink":"https://hexo.kbrx93.com/tech/SpringMVC-execution/","excerpt":"前言：针对SpringMVC的源码来初步分析其执行流程","text":"前言：针对SpringMVC的源码来初步分析其执行流程 总体流程 如下图： 执行过程： 源码分析 从DispatcherServlet入手. 请求进来都会先去找service方法 此方法在父类FrameworkServlet中 发现执行processRequest方法，点击进入 其中关键调用了doService方法，此方法在FrameworkServlet定义为抽象，即由DispatcherServlet实现 即实际上执行Dispatcher中的doService方法 查看doService方法 查看doDispatch方法（重点） 整个方法体： 按步骤来： 第一部分 先判断是否二进制请求，并进行相关处理 然后调用getHandler方法获得处理执行链对象 具体方法体： 第二部分 获得真正Handler的执行者HandlerAdapter 第三部分 开始执行拦截器及Handler 其中的具体方法体如下： applyPreHandle方法 applyPostHandle方法 processDispatcherResult方法 其中render方法体： triggerAfterCompletion方法体： 写在最后 主要是从源码上分析并记录初步的执行流程，话说一个好的截图工具真的能节省很多的时间。。。","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://hexo.kbrx93.com/tags/框架/"},{"name":"源码","slug":"源码","permalink":"https://hexo.kbrx93.com/tags/源码/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hexo.kbrx93.com/tags/SpringMVC/"},{"name":"执行流程","slug":"执行流程","permalink":"https://hexo.kbrx93.com/tags/执行流程/"}]},{"title":"SpringMVC——HelloWorld篇","slug":"2018-01-31SpringMVC——HelloWorld篇","date":"2018-01-30T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/springmvc-helloworld/","link":"","permalink":"https://hexo.kbrx93.com/tech/springmvc-helloworld/","excerpt":"前言：这篇笔记主要是记录SpringMVC的HelloWorld(初学习)","text":"前言：这篇笔记主要是记录SpringMVC的HelloWorld(初学习) 准备 Intellij IDEA 2017.3.3 Tomcat：8.5 Spring：4.0 + SpringMVC：4.0+ JSTL：1.2 Servlet：4.0 web.xml的版本：2.3(这里的版本对之后的配置有一点小影响) 主要过程 用IDEA搭建Maven工程，并完善相关目录结构 pom.xml中引入相关依赖 编写核心类（在这里是Controller类） 配置SpringMVC配置文件application.xml及web.xml的相关配置项，分两种： 全注解（最常用） 在配置文件中配置bean的方式(了解即可) 编写JSP并运行Tomcat进行相关测试 过程中遇到的问题 详细过程 记录详细的过程 环境搭建 用IDEA搭建Maven工程，并完善相关目录结构 选择搭建Maven工程，并使用maven-webapp模板 填写相关的groupId和ArtifactId 最后Finish即可 因为默认的模板的目录结构是不完整的，所以还需要手动补全，如下图 引入依赖 pom.xml中引入相关依赖 &lt;dependencies&gt; &lt;!-- ============Spring相关============ --&gt; &lt;!-- Spring-Context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring-AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ============Spring MVC相关============ --&gt; &lt;!-- Spring-WebMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring-Web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ============Servlet相关============ --&gt; &lt;!-- JSTL --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写核心类 注解方式 /** * @author: kbrx93 */ @Controller public class AnnotationController { @RequestMapping(\"/annotation_hello\") public void sayHello() { System.out.println(\"AnnotationController.sayHello\"); } } 继承接口方式 /** * SpringMVC HelloWrold * * @Author: kbrx93 */ public class HelloWorldController implements Controller{ @Override public ModelAndView handleRequest( javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse ) { System.out.println(\"This is the SpringMVC Hello World example!\"); ModelAndView mv = new ModelAndView(); mv.addObject(\"user\", \"kbrx93\"); mv.setViewName(\"index.jsp\"); return mv; } } 编写配置文件 对应注解方式（“扫”、“驱”、“静”） 注意要在文件头引入xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; 和 http://www.springframework.org/schema/mvc &lt;!-- 全注解方式配置(扫驱静) --&gt; &lt;!-- 1. 开启扫描（biubiubiu～～） --&gt; &lt;context:component-scan base-package=\"com.kbrx93.controller\"/&gt; &lt;!-- 2. 引入注解驱动 --&gt; &lt;!-- 不是必要条件，但最好加上。 一句话：你的手机通信加上之后可能就由移动变成联通了，提供的服务相同，但组件不同。 并且相对来说更加可控 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 3. 静态资源处理Servlet（因为拦截“/”覆盖掉原本的Tomcat中处理静态资源的Servlet） --&gt; &lt;!-- 静态资源：你把老子相好拦下来了却不打算干点什么？？？ --&gt; &lt;mvc:default-servlet-handler/&gt; 对应接口方式 &lt;!-- name属性即为访问的路径 --&gt; &lt;bean name=\"/hello\" class=\"com.kbrx93.controller.hello.HelloWorldController\"&gt;&lt;/bean&gt; 运行测试 /webapp/show.jsp文件如下： &lt;%-- Author: kbrx93 --%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; ${user} &lt;/body&gt; &lt;/html&gt; 运行Tomcat测试结果： 问题 记录过程中遇到的问题 ${user}EL表达式在JSP中不生效？？？ 主要是由于web.xml文件中声明xsd版本问题（前面提到的），一般有以下几种： web-app_2_2.xsd &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN\" \"http://java.sun.com/dtd/web-app_2_2.dtd\"&gt; web-app_2_3.xsd &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\"&gt; web-app_2_4.xsd &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"2.4\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt; web-app_2_5.xsd &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" version=\"2.5\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"&gt; web-app_3_0.xsd &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;/web-app&gt; web-app_3_1.xsd &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;/web-app&gt; ​ 其中只有2.4和3.1版本的EL解析开关是默认打开的，其它都是关闭的，所以自然而然解决方法就有两种： 更换声明为2.4或3.1版本 ]()在每一个使用到EL表达式的JSP页面的开头&lt;%@ page %&gt;标签中加上isELIgnored=&quot;false&quot;属性，即 &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt; 使用注解方式调用返回值为null的方法发生404？？？ 由于使用了注解，所以对于方法的返回值、方法名、参数等没有了限制，但是要注意，如果在参数中没有注入一个HttpServletResponse参数，那么就一定要返回一个模型视图对象。（除非配置了视图解析器）可以理解为一定要有一个响应对象。 在项目的web.xml文件中配置了拦截/请求（即所有）的DispatcherServlet，之后直接访问静态资源时如*.html等报404错误？？？ 这是因为在Tomcat的web.xml中也配置了一个拦截/的默认Servlet，默认的静态资源本来也会由它处理，但是由于后加载的项目的web.xml也有一个拦截/的Servlet，故被覆盖了，然而静态资源在SpringMVC项目中却没有进行相关的配置，故404。 解决方法即在配置文件application.xml中引入&lt;mvc:default-servlet-handler/&gt;，将静态资原交由SpringMVC的默认Servlet处理即可。 写在最后 这篇主要是对SpringMVC做一个初步的认识，后面对其执行流程及基本组件会加以补充。","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://hexo.kbrx93.com/tags/框架/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hexo.kbrx93.com/tags/SpringMVC/"},{"name":"MVC","slug":"MVC","permalink":"https://hexo.kbrx93.com/tags/MVC/"},{"name":"HelloWorld","slug":"HelloWorld","permalink":"https://hexo.kbrx93.com/tags/HelloWorld/"}]},{"title":"杂记","slug":"2018-01-27杂记","date":"2018-01-26T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"think/random_record/","link":"","permalink":"https://hexo.kbrx93.com/think/random_record/","excerpt":"23,一个半醉不醒的年纪","text":"23,一个半醉不醒的年纪 热爱 昨天在看一档电视节目，里面说到出租车司机被另一个同行杀害，原因仅是因为以15元的价格拉走了同行原本谈好的20元的客人。5元一条命，说起来也不是太贵。 当我看到这个报道的时候，起初是不解的，为什么就为了金钱上(还不是巨额)的一点小矛盾就可以不顾后果地掠夺别人的生命，因为愤怒、嫉妒的负面情绪而摧毁别人，这种行为从骨子里就透出一种悲哀。 当一个人的生活中出现这种被称为一时冲动的行为时，我更愿意称之为一时暴露，换言之，生活常态是被压抑，这是其一。 另外，这从本质上也意味着他根本没有看着生活的核心，即生活能带给他快乐的方式或东西。我相信每一个明白这一点的人都不会做出这样的行为。他们会愤怒，会不安，会惶恐，但一定会执着地热爱生命。 悖论 这个报道突然让我想到电影21克，说的是人的灵魂重21克，我突然想知道，我的命值多少钱，重多少克。 或许一文不值，或许无价。 但无论如何，这个问题在我活着的时候是无法得到解答的。你看很矛盾吧，人讨论别人的时候总是能以最精明，最刁钻，最看上去有见解的话去点评，但一旦涉及到了自己，问题往往成为悖论。 命三 我常对自己说:命数有三，三不由二。我决定不了我的开始和结束，总能让我决定活着的过程吧。 所谓中庸 我很怕死，很怕改变，很怕改变带来的离开。我不是一个坚定的人，一直都不是，所以一旦有改变，害怕，但却不够坚定表现出来，所以表现出来一种适度，一种随遇而安，一种所谓中庸的生活态度。 真难看。 做 &amp; 听 聪明人说废话，有两种，一种两头不得罪，所以圆滑地说，一种老生常谈，所以不断地说。 第一种做一点，第二种听一点。 23，半醉不醒 写这篇笔记的时候23岁，怎么说，一个还可以做做文艺梦，过几年再看不会太尴尬，还能笑一笑的年纪，有一个幸福很幸福的家庭：父母健在，生活过的不富有，却知足，知足常乐。 生活在改变，生命在蜕变。定位自己，思考自己。你我进去自己的脑海，开始生活，而家人开始增加或减少，开始惶恐不安，开始忘掉一些东西，也开始记起一些东西。开始努力忘掉一些东西，也开始拼命记起一些东西。 开始失去，并学着接受。 希望能学会。 23，如果可以，醉得深些，醒得快些。 胡说 不曾饮酒，却呓语连篇，哈哈。 祝安。","categories":[{"name":"think","slug":"think","permalink":"https://hexo.kbrx93.com/categories/think/"}],"tags":[{"name":"随便说点什么","slug":"随便说点什么","permalink":"https://hexo.kbrx93.com/tags/随便说点什么/"},{"name":"胡说","slug":"胡说","permalink":"https://hexo.kbrx93.com/tags/胡说/"}]},{"title":"归家","slug":"2018-01-20归家","date":"2018-01-19T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"think/record_back_home/","link":"","permalink":"https://hexo.kbrx93.com/think/record_back_home/","excerpt":"要是 彼此都有些 既定路程， 学会洒脱，好吗","text":"要是 彼此都有些 既定路程， 学会洒脱，好吗 [00:00.00] 作曲 : Eric Kwok/Eason Chan [00:01.00] 作词 : 黄伟文 [00:15.22] 流水 像清得没带半颗沙 [00:21.68] 前身 被搁在上游风化 [00:27.75] 但那天经过那条堤坝 [00:31.52] 斜阳又返照闪一下 遇上一朵 落花 [00:41.19] 相遇 就此拥着最爱归家 [00:47.63] 生活 别过份地童话化 [00:54.05] 故事 假使短过这 五月落霞 [01:00.28] 没有需要 惊诧 [01:06.58] 流水很清楚 惜花这个责任 [01:11.51] 真的身份不过送运 [01:14.72] 这趟旅行若算开心 [01:18.99] 亦是无负这一生 [01:21.16] 水点 蒸发变做白云 [01:24.46] 花瓣 飘落下游生根 [01:28.18] 淡淡交会过 各不留下印 [01:43.68] 流水 在山谷下再次分岔 [01:49.25] 情感 渐化做淡然优雅 [01:55.29] 自觉心境已有如明镜 [01:58.92] 为何为天降的稀客 泛过一点 浪花 [02:08.66] 天下 并非只是有这朵花 [02:15.22] 不用 为故事下文牵挂 [02:21.64] 要是 彼此都有些 既定路程 [02:27.58] 学会洒脱 好吗 [02:33.67] 流水很清楚 惜花这个责任 [02:38.36] 真的身份不过送运 [02:41.70] 这趟旅行若算开心 [02:45.36] 亦是无负这一生 [02:48.17] 水点 蒸发变做白云 [02:51.36] 花瓣 飘落下游生根 [02:55.30] 命运敲定了 要这么发生 [03:00.44] 讲分开 可否不再 用憾事的口吻 [03:05.10] 习惯无常 才会庆幸 [03:08.30] 讲真 天涯途上 谁是客 [03:10.83] 散席时 怎么分 [03:15.67] 流水很清楚 惜花这个责任 [03:19.92] 真的身份不过送运 [03:23.22] 这趟旅行若算开心 [03:26.80] 亦是无负这一生 [03:29.74] 水点 蒸发变做白云 [03:32.97] 花瓣 飘落下游生根 [03:36.59] 淡淡交会过 各不留下印 [03:43.50] 但是经历过 最温柔共震 [03:52.40] [03:56.40] var ap = new APlayer({ element: document.getElementById(\"aplayer1\"), narrow: false, autoplay: false, showlrc: 2, music: { title: \"落花流水(2010 duo)\", author: \"陈奕迅\", url: \"https://stu2015jnueducn-my.sharepoint.com/personal/kbrx93_stu2015_jnu_edu_cn/_layouts/15/download.aspx?e=kTwAIi&share=ETSu_EGg9gBHqU2wl59eBRABAqjGFsQawdt7BFAmau3axg&ithint=.mp3\", pic: \"https://image-1251774567.cosgz.myqcloud.com/blog/2018-01-30-2010_duo.jpg\", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 回家了 经过“漫长”的归途，终于回家了！ 看着倒流过去熟悉或陌生的景物，本以为自己会有蛮多感触的。 然而，并没有。 或许是习惯了离开吧。 回来了 说起来可能也是一种矫情，在离开学校前总有一种淡淡的不舍，在假期完了要离开家的时候亦是如此，想着自己以后可能很久一段时间不能再看到相同的场景了，总是观察地那么仔细，好显得自己的不舍。 其实人啊，哪有那么多的离情愁绪，你认为可能会改变的地方，也许在没有你的时光里一点也没变，只是你变了；你认为可能会再也看不到并且想念的人可能对你来说并没有那么地重要，在没有彼此的时光里，你们一样可以活地很好。 甚至活得更好，只是你不愿相信，所以执着于想念。 不舍只是因为习惯了环璄，习惯了身边的人，习惯了做事的步骤，习惯了每天醒来要考虑的问题及解决方案，并且害怕着改变。当然这是对我自己来说，也有的人喜欢冒险，喜欢改变的生活，但是换种角度想想，这其实也是一种习惯，习惯“改变”，并且害怕一成不变的生活。 回去了 其实仔细想想，从小学到初中，再到高中、大学及至工作中，生活就是一个不断离开的过程，有新的人加入你的生活，充满惊喜与未知；有熟悉的人逐渐淡出你的生活，只剩回忆。 在我看来，回忆只适合出现在两种情况： 拌酒，还有买醉。 一种品，一种醉。 当然，品着品着可能也醉了，无伤大雅。 兜兜转转，一圈又一圈，回来了，也回去了。 呵呵，胡言乱语。 最后， 祝安。","categories":[{"name":"think","slug":"think","permalink":"https://hexo.kbrx93.com/categories/think/"}],"tags":[{"name":"回家","slug":"回家","permalink":"https://hexo.kbrx93.com/tags/回家/"},{"name":"随笔","slug":"随笔","permalink":"https://hexo.kbrx93.com/tags/随笔/"}]},{"title":"关于2018的个人打算","slug":"2018-01-18关于2018的打算","date":"2018-01-17T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"think/plan_in_2018/","link":"","permalink":"https://hexo.kbrx93.com/think/plan_in_2018/","excerpt":"宏愿纵未了， 奋斗总不太晚。","text":"宏愿纵未了， 奋斗总不太晚。 [00:00.00] 作曲 : Vincent Chow [00:01.00] 作词 : 黄伟文 [00:15.01]过去十八岁 没戴表 不过有时间 [00:22.04]够我 没有後顾 野性贪玩 [00:29.06]霎眼廿七岁 时日无多 方不敢偷懒 [00:35.02]宏愿纵未了 奋斗总不太晚 [00:40.05] [00:41.06]然後突然今秋 望望身边 应该有 已尽有 [00:49.04]我的美酒 跑车 相机 金表 也讲究 [00:56.07]直到世间 个个也妒忌 仍不怎麽富有 [01:04.04]用我尚有 换我没有 其实已 用尽所拥有 [01:10.06] [01:11.01]曾付出几多心跳 来换取一堆堆的发票 [01:18.03]人值得 命中减少几秒 多买一只表 [01:25.06]秒速 捉得紧了 而皮肤竟偷偷松了 [01:32.05]为何用到尽了 至知哪样紧要 [01:39.04] [01:52.09]劳力是 无止境 活着多好 不需要 靠物证 [02:01.01]也不以高薪 高职 高级品 搏尊敬 wo~ [02:08.02]就算搏到 伯爵那地位 和萧邦的隽永 [02:16.01]卖了任性 日拼夜拼 忘掉了为甚麽高兴 [02:22.00] [02:22.07]曾付出几多心跳 来换取一堆堆的发票 [02:29.08]人值得 命中减少几秒 多买一只表 [02:37.04]秒速 捉得紧了 而皮肤竟偷偷松了 [02:44.01]为何用到尽了 至知哪样紧要 [02:50.05] [02:51.06]记住那 关於光阴的教训 [02:55.07]回头走 天已暗 [02:58.05]你献出了十寸 时和分 [03:02.09]可有换到十寸金 [03:06.07] [03:09.00]还剩低几多心跳 人面跟水晶表面对照 [03:16.05]连自己 亦都分析不了 得到多与少 [03:24.00]也许真的疯了 那个倒影多麽可笑 [03:30.07]灵魂若变卖了 上链也没心跳 [03:37.03] [03:38.00]银或金都不紧要 谁造机芯 一样了 [03:44.05]计划了 照做了 得到了 时间却太少 no~ [03:52.02]还剩低几多心跳 还在数赶不及了 [03:59.07]昂贵是这刻 我觉悟了 [04:07.03]在时计里 看破一生 渺渺 [04:19.06] var ap = new APlayer({ element: document.getElementById(\"aplayer0\"), narrow: false, autoplay: false, showlrc: 2, music: { title: \"陀飞轮(2010 duo)\", author: \"陈奕迅\", url: \"https://stu2015jnueducn-my.sharepoint.com/personal/kbrx93_stu2015_jnu_edu_cn/_layouts/15/download.aspx?e=2G7Ijh&share=EfFcHpKdWvFOjhTMAzMmJsMB0eMtLcdHUB_J6WpD1Iblsg&ithint=.mp3\", pic: \"https://image-1251774567.cosgz.myqcloud.com/blog/2018-01-30-2010_duo.jpg\", } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 过去 不知不觉就到了2018了。 大三也已经过去了一半，看看自己： 半分不争气。 年少时的人总盼着沧桑，而年长时却渴望着天真。 得不到的总是最牵挂得紧，不外是如。 似乎只有在二十几岁的阶段里，人才会不那么在意自己的年纪，让时光肆意地流淌。 希望自己回首时能留下一些东西。 现在 开始「画大饼」了，哈哈。 主要有： 编程开发 语言类 英语 日语 书籍 编程方面书籍 其它方面 编程开发 下学期就大三下了，对工作实习方面的需求也就紧迫了起来，对自身的动手能还是比较高，因此在编程方面还是要下一番功夫的，毕竟现在的水平实在是有限。 主要有： 自己动手写 阅读源码、文档、好的博客学习 写博客 主要的方向还是Java开发，但是可以加一些对Python、人工智能等的基础的学习和了解。 针对自己动手的目标，我的打算是能在下学期结束前完成10个项目的Github上传，在一整年的时间是20个，不知道对我来说是难或易，总之先尝试看看，当然项目是比较完整的项目或系统，同时最好多敲几遍，自己理解透了才算过。 阅读源码和文档这方面主要针对Java源码的学习，如果可以的话，可以多阅读一些比较经典的框架源码、文档或是别人好的博客，如Spring等。（当然不是全部，有针对性阅读） 在写项目和阅读过程中的想法和错误感悟等都可以写下来，目标是在下一年博客的笔记能达到100条。 语言 因为如果想针对比较新的技术的话，直接读英文文档总是最直接的方式，所以学好英语总是很必要，说不定以后代码敲不下去了，能当当什么日语老师也是不错的，哈哈。 日语方面的希望下一年能学到标日中级，要求不高吧。。 主要是课本上的单词及句式。（多去图书馆。。。机会不多了） 英语方面的话目前是没有什么计划吧，多听多练口语吧。 书籍 发现自从上大学以来，心越来越静不下来，很少有花时间在读书这一方面，而且在工作了之后可能这种能让你安静下来的机会会越来越少。 专业方面的书籍 目前暂定的有 《Java编程思想》 《深入理解Java虚拟机》 《Effective java 中文版（第 2 版）》 待续 其它方面 这一方面就是随便看，我的观点就是只要是看一些你认为值得看的书就行，那你在看的过程中都充满着价值。（多利用图书馆资源） 写在最后 目前想到的就这些，希望自己可以做到吧！ 最后，感谢生命中每个遇到的人或事。 活着真好。 祝安。","categories":[{"name":"think","slug":"think","permalink":"https://hexo.kbrx93.com/categories/think/"}],"tags":[{"name":"2018","slug":"2018","permalink":"https://hexo.kbrx93.com/tags/2018/"},{"name":"plan","slug":"plan","permalink":"https://hexo.kbrx93.com/tags/plan/"}]},{"title":"关于Mac上自动切换输入法的记录","slug":"2017-12-3关于Mac上自动切换输入法的记录","date":"2017-12-03T14:45:54.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"other/change_input_method/","link":"","permalink":"https://hexo.kbrx93.com/other/change_input_method/","excerpt":"前言：首先，对于Mac上在不同应用上的输入法混乱问题我感到非常不适应，于是想搞一套可以根据应用自动切换对应输入法的工作流程（类似于百度及搜狗输入法的安静模式，但我所使用的清歌输入法却没有，加之前面两者的字排序我十分不满意，还不能手动调频，所以才想自己搞一下）。以下是过程相关记录（写得比较粗糙。。）","text":"前言：首先，对于Mac上在不同应用上的输入法混乱问题我感到非常不适应，于是想搞一套可以根据应用自动切换对应输入法的工作流程（类似于百度及搜狗输入法的安静模式，但我所使用的清歌输入法却没有，加之前面两者的字排序我十分不满意，还不能手动调频，所以才想自己搞一下）。以下是过程相关记录（写得比较粗糙。。） 环境准备 系统：Mac10.12.6 Karabiner-Elements：11.3 Keyboard Macstro：8 主要思路 需要英文输入的时候切换到自带的英文输入法 需要中文输入的时候切换到清歌输入法（不使用输入法内置的英文输入） 具体分成两部分 针对特定应用切换成指定的输入法，切出来的时候切换成另一种输入法 这个比较简单，直接用Keyboard Macstro即可 将shift键搞成切换输入法的开关 本来直接将shift用Karabiner-Elements映射成F19，然后在偏好设置里将F19设置为切换输入法的快捷键就可以，但是为了在清歌输入法下输入了两三个字符后再切换时保留已输入的字符，在切换之前输入两次Fn键（对应清歌输入法里的切换中英文的开关），就可以保留已输入的字符了。 具体代码如下： { \"description\": \"left_shift to f19 (in 300milliseconds) when press one\", \"manipulators\": [ { \"type\": \"basic\", \"from\": { \"key_code\": \"left_shift\", \"modifiers\": { \"optional\": [ \"any\" ] } }, \"to\": [ { \"key_code\": \"left_shift\" } ], \"parameters\": { \"basic.to_if_alone_timeout_milliseconds\": 300 }, \"to_if_alone\": [ { \"key_code\": \"fn\" }, { \"key_code\": \"fn\" }, { \"key_code\": \"f19\" } ] } ] } 写在最后 本来看到有了小软件GhostSBK，以为能智能地切换输入法，但是结果却大失所望（浪费了45元。。。），存在的问题是切入一个程序会切换输入法，但切出来的时候不会自动切回去，作者好像也没有加黑白名单的准备。。 对我的Mac系统上的快捷键映射方式作一个总结： 系统自带的修改映射的方式：在系统偏好设置-键盘-快捷键-应用快捷键中可以修改，这一种主要用于对应应用上左侧菜单上选项的快捷键，十分好用。 Karabiner-Elements + Keyboard Macstro 两者作用有重复，但我用Karabiner-Elements用来映射单键及录制不到的键（如shift等）的映射（其实是可以的，用脚本检测触发即可），其它的全用Keyboard Macstro（太强大了） 最后附上完整定义脚本。","categories":[{"name":"other","slug":"other","permalink":"https://hexo.kbrx93.com/categories/other/"}],"tags":[{"name":"input_method","slug":"input-method","permalink":"https://hexo.kbrx93.com/tags/input-method/"},{"name":"mac","slug":"mac","permalink":"https://hexo.kbrx93.com/tags/mac/"}]},{"title":"计算机编码的一些后续补充","slug":"2017-11-16计算机编码的一些后续补充","date":"2017-11-16T15:42:29.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/computer_character_encoding2/","link":"","permalink":"https://hexo.kbrx93.com/tech/computer_character_encoding2/","excerpt":"前言：写这篇笔记的目的，主要是为了补充一下前面计算机编码那篇笔记没有提到的在计算机内部文件存储及内存中的编码问题，以及编码转化的一些简单介绍。日后如果发现还有一些关于编码的问题需要记录也一并写在这里，就不写在之前的笔记里了。","text":"前言：写这篇笔记的目的，主要是为了补充一下前面计算机编码那篇笔记没有提到的在计算机内部文件存储及内存中的编码问题，以及编码转化的一些简单介绍。日后如果发现还有一些关于编码的问题需要记录也一并写在这里，就不写在之前的笔记里了。 文件存储与内存中的编码 回答一个问题：为什么要使用UTF-8？ 除了大家都使用之外，很重要的一点，就是UTF-8节省空间，这里的节省空间，是指对于英文字符来说（用一个字符即可），而对于中文字符来说，反而相比起GBK之类的要多占用一些空间（一般3个），所以对于中文开发者来说，使用UTF-8其实不是一个特别好的选择，但是大环境是：欧美那边是计算机的主导者。。所以。。 以UTF-8为例 为什么要在内存中使用Unicode而不直接使用UTF-8？ 因为在内存中的数据要考虑我们进行的操作时是否方便，Unicode是等长字节，UTF-8是变长字节。（如下面的图） 对比起来肯定是Unicode操作方便 而在存储的时候，自然就选择能更省空间的UTF-8了。 其它零碎的点 提及一下：在Windows记事本里，Unicode具体是指UTF-16 LE（比较坑，注意一下） cp936是指GBK（在Windows系统下为936的代码页故有此称） 关于URL编码（这篇文章已经写得很详细了，值得一看，附上转换的一段Java代码，以便理解GetFilecharset.java） 简单的编码识别与转化 参考 在计算机中为何不直接使用UTF8编码进行存储，而要使用Unicode再转换成UTF8？","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"encoding","slug":"encoding","permalink":"https://hexo.kbrx93.com/tags/encoding/"}]},{"title":"Java中文件读取路径学习记录","slug":"2017-11-15Java中文件读取路径学习记录","date":"2017-11-14T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/Java_File_Path/","link":"","permalink":"https://hexo.kbrx93.com/tech/Java_File_Path/","excerpt":"前言：最近在写算法题时用到从文件中读取相关记录，发现对Java读取文件时的路径不是很清楚，网上相关文章很多，在此仅作记录与自我复习使用。如有不对之处，请批评指正。","text":"前言：最近在写算法题时用到从文件中读取相关记录，发现对Java读取文件时的路径不是很清楚，网上相关文章很多，在此仅作记录与自我复习使用。如有不对之处，请批评指正。 相对路径与绝对路径 相对路径：指不是从硬盘的根路径出发的路径，如./algorithm之类的路径，较为灵活。 注意，实质上所有的相对路径都是API在底层帮你加上了前面省略的路径，最终还是拼成绝对路径在系统中查找。 绝对路径：当然就是指从硬盘的根开始的路径，如/Users/kbrx93/IdeaProjects/algorithm，较为固定。 优缺点：没有绝对的优缺点，在实际的开发中看情况使用。 Java Project与JavaWeb Project 这里从普通Java工程和JavaWeb工程两个方面来说明，每个方面又都可以分为io（即File类）和classpath路径下读取。 JavaProject 先给出目录结构 File类查找(不推荐) 相对路径：如上面查找1.txt文件，可用File f = new File(&quot;1.txt&quot;)或File f = new File（“./1.txt”），理论上可以用这种方法可以查找你在项目中所有的文件（自然也可以查找到classpath路径下的文件），但是 非常不推荐 这种方法，原因有二： 一是这种方法底层实际上是用System.dir的系统变量 + 你写的路径来拼接成绝对路径查找，如System.getProperty(&quot;user.dir&quot;) + &quot;/1.txt&quot;，而System.dir指的是你调用这个程序时的目录，简单点来说，如果某一天你突发奇想，在根目录/下在命令行调用你写的Java代码，你所找的路径实质上就变成了/1.txt，自然就找不到了。因此这种方法非常不可靠。 第二个原因是在实际的开发中一般会将配置文件、资源文件等放在classPath目录下，可以通过字节码对象或类加载器读取文件，因此一般不用上面所提的方法。 绝对路径：这个就没什么好说的，就是直接把目录的绝对路径写上去查找，如/Users/kbrx93/IdeaProjects/learnGit/1.txt，由于不灵活，一般也不采用，在进行简单测试的时候也可以用一下。 classpath路径文件查找（实际中经常使用） 使用这种方式程序底层自动拼接classpath在系统中的路径。 classpath路径：通俗地来说就是你的HelloWorld.java文件编译完成后的HelloWorld.class文件的路径，实际上不只是java文件，你放在需要输出的文件夹如src中的文件都会输出到classpath路径下。 注意：这里提到的src目录指的是配置在classpath路径中的src（具体如何查看及配置classpath路径请自行Google），简单点来理解就是classpath老大指定了二掌柜的职位，只不过刚好招到的二掌柜的名字就叫二掌柜。。类比我们新建的目录src，当了二掌柜的职位（classpath路径下的src）。 通过字节码对象获取 相对路径：如写成HelloWorld.class.getResource(&quot;8.txt&quot;)，用哪个class文件，就在对应的目录下开始找（不是特别好用，因为目录与你所选用的class文件有直接的关系） classpath根路径：如写成HelloWorld.class.getResource(&quot;/8.txt&quot;)，说白了，就是路径从/开始就从classpath目录往下找，/就代表了classpath根路径 通过类加载器获取（最佳实践） 直接就从classpath根目录下查找（因此开头无需加/，当然也不能加，会报错）：HelloWorld.class.getClassLoader().getResource(“8.txt”) 注意：这里就与你用的类无关了，因为都是从classpath根路径开始找，当然，也可以找classpath根路径的上一级，用..表示查找上一级目录，但是不能用..的相对路径跨jar包访问。这里的表述可能不是很清晰，具体可以参考java文件读取的路径问题解惑和最佳实践中使用Class或ClassLoader.getResource()的相对路径和绝对路径问题部分，这里不再赘述了。 最佳实践（返回URL对象）： Thread.currentThread().getContextClassLoader().getResource(&quot;8.txt&quot;) 最佳实践2（返回InputStream对象）： Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;8.txt&quot;); JavaWeb Project 大体上与上一部分是相同的，主要讲一下不同之处。 在JavaEE中，类加载器从web应用的/WEB-INF/class文件夹下开始查找文件 如果是在Servlet中，可以用ServletContext对象来读取，如getServletConfig().getServletContext().getRealPath(“/1.txt”);这里的/可写可不写，这是在webapp目录下的，可以用这种方法来读取整个webapp下的文件 如果是在/WEB-INF/classes目录下，可以用上面所说的通过字节码对象获取及通过类加载器获取，通过类加载器获取的开头的/可写可不写，不强制不能写，作用是一样的。 如果使用了相关的框架，框架可能会对其进行功能扩展或包装之类，请自行参考框架的文档关于读取文件的部分 跨平台 如果路径完全不同，请使用配置文件，也推荐使用。 这里只是简单提及一下。 例子：Windows上： File f = new File(“C:\\\\test\\\\demo.txt”); ​ Linux上： File f = new File(“/test/demo.txt”); 最终：File f = new File(&quot;C:&quot; + File.separator + &quot;test&quot; + File.separator + &quot; demo.txt&quot;); 参考 Java开发中文件读取方式总结 java文件读取的路径问题解惑和最佳实践","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.kbrx93.com/tags/Java/"},{"name":"path","slug":"path","permalink":"https://hexo.kbrx93.com/tags/path/"}]},{"title":"计算机编码学习小记-字符编码、MIME编码","slug":"2017-11-09计算机编码学习","date":"2017-11-08T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"tech/computer_character_encoding/","link":"","permalink":"https://hexo.kbrx93.com/tech/computer_character_encoding/","excerpt":"前言：写这一篇文章的动机主要是在前面做markdown图片批量下载小工具时遇到过编码问题，发现自己对于计算机内部的编码了解甚少，于是想较为系统地学习一下。这篇笔记记录的主要是计算机内部的编码，至于在网络传输过程中编码的过程和问题以及在各种编程语言中的编码问题不在讨论范围之中，如果以后有时间或者有需要再写吧。不对或不妥之处，请批评指正。","text":"前言：写这一篇文章的动机主要是在前面做markdown图片批量下载小工具时遇到过编码问题，发现自己对于计算机内部的编码了解甚少，于是想较为系统地学习一下。这篇笔记记录的主要是计算机内部的编码，至于在网络传输过程中编码的过程和问题以及在各种编程语言中的编码问题不在讨论范围之中，如果以后有时间或者有需要再写吧。不对或不妥之处，请批评指正。 准备知识 什么是计算机编码？ 在我们日常生活中，用各种各样的语言进行交流，而每一种语言实际上就是一套字符集合，中文的“你”，英文的“you”等，都是字符。这没有任何问题，但是对于计算机来说，问题就出现了，它只认识 0 和 1 ，其它的什么东西都不认识。 于是对于计算机而言，就需要一个表，当你输入y保存的时候，它去这个表里查对应的01序列（假设y对应的是000110 ），找到了对应的01序列后就将其保存磁盘上 下一次你要打开这个文件，计算机就去找表里对应000110的字符是什么，知道这个字符是y后，就显示出来（经过其它操作） 于是y在计算机中变成000110的过程就叫编码（编成01代码串），相反过来从000110到y的过程叫解码。 还有因为000110对于人来说可能看得不直观，我们一般将其转化为十进制表示（在这里就是6），所以可以说y就对应表中的6 什么是字符集？什么是字符编码？两者的区别是什么？ 前面说了，生活中使用到的字符需要经过编码才能让计算机识别和使用，所以关键就是那张让计算机进行转化的表 字符集说白了就是这张表，这张表里规定了整数10代表了哪个字符，11代表了哪个字符，12代表了哪个字符之类的。 字符编码是指有了这张表，我们如何进行编制的问题，举个例子来说明可能容易理解一些：假设在表中（捏造的） 1 代表了字符o 20 代表了字符k 计算机读取 3 个字节，发现是0000 0000 0001，明白了：哦，原来这个字符是o，再读取3个字节，发现是1100 0001 1110，明白了：原来这个字符是k。看上去没有问题，一切都很完美。但是，对于第一个字符来说，为什么不省略前面的8个0，只写0001就让计算机知道：哦，这个是o呢？ 所以，经过上面的例子我们可以知道，这张表规定了1代表了一个字符，但是1 用01序列表示的话，可以表示成0001，也可以表示成0000 0001,这就是不同的字符编码方式，也就是告诉计算机一次该读几个字节（定长）或者读取到什么信息就结束读取进行转化（可变长），然后去表中查找相应的字符，这样的一套编码方式就叫***字符编码***。（关于定长和可变长参看后面，这里不理解可以先跳过） 特别注意，GBK及ASCII等，既可以指一张表（字符集），又指字符编码。这张表里8个bit代表一个字符，那计算机你就每次读8位，再看看对应什么字符好了。但是对于更大的字符集（如Unicode）而言，每次读4个字节太浪费时间（如上面的例子），用0001还是用0000 0001来表示表中的1就成了问题，所以针对Unicode来说有不同的字符编码方式（UTF-8、UTF-16之类的）。 什么是内码？ 个人觉得就是字符集。 主要内容 字符编码 经过上面的解释，我们可以知道计算机需要一张表，但是呢，世界上有很多种语言，所以不同地区的计算机上的表其实是不一样的。。。所有就有了乱码问题。 计算机字符集可分为三类：单字节字符集(SBCS)、多字节字符集(MBCS)和宽字符集(即Unicode字符集)。 单字节字符集(SBCS)：表中的01序列为一个字节（8bit），即用一个字节一个字符，如：ACSII 多字节字符集(MBCS)：表中的01序列为一个或多个字节，即用一个或多个字节表示一个字符，如ANSI中的各种字符集 宽字符集(即Unicode字符集)：表中的01序列为2个字节，即用两个字节表示一个字符。（刚出来是2个字节，后来发现不够用，已更新了一组附加字符编码，用4个字节表示一个字符） 以下介绍几种常用的字符编码，更加全面请参考百科字符编码 ASCII 大小为 1 个字节（8bit，可表示0～255共256个数），格式为0XXXXXXX 填入了英文字符及一些不可见字符（如换行等） 填入后发现只用了一半的编码（128个字符），但为了便于传输和保存，干脆在前面增加一个0，这样刚好湊够一个字节 EASCII 大小为1个字节，格式为1XXXXXXX 对ASCII的扩展，用了ASCII没用完的后面码位 ISO/IEC 8859-1 这个是比较常见的ASCII扩展字符集 ANSI 在最开始，ANSI指的是Windows自己设计的一套编码，对应的在Code Page号是1252，被称为Windows 1252。由于ANSI是大部分参照（可以说基本一样）ANSI草案(ANSI Draft)，后来这个ANSI草案最终正为了一个正式标准ISO 8859-1，所以最开始的ANSI字符集和ISO 8859-1基本一样。 但是现在来说，大多数人口中的ANSI编码并不是指代一套特定的编码，而是是本地编码，可能在简体中文的Windows系统上ANSI指GB2312，在日文Windows系统上ANSI编码代表 JIS 编码等。（注意，ANSI是在ASCII的基础上进行扩展的，故向下兼容ASCII） 中文 GB2312、GBK、GB18030 关系：ASCII ==〉GB2313 ==〉GBK ==〉GB18030 （包含的内容递增，并向下兼容） 由于中文编码较为复杂，具体可以看下字符编码详解——彻底理解掌握编码知识，“乱码”不复存在中GB编码部分，如遇需要再做记录。 Unicode 注意，网络上有的文章说Unicode是2个字节，有的说是4个，这是因为Unicode刚出来的时候2个字节来就足够编码了，但在发展过程中发现65536个码位不够用，就更新了规范，增加了辅助平面，用4个字节来表示新增的字符，而之前的常用编码保持不变，称为基本多文种平面（BMP），编码从U+0000至U+FFFF，更具体的可以参见百科。 UTF-8 可变长度Unicode字符编码 采用1～4个字节来表示Unicode码 注意Unicode中的UTF-8是可变长的多个字节，前面的MBCS字符集也是多个字节，有什么区别？ MBCS字符集即表中中文你可能就是两个字节1000 1000 1000 0001，而o则是一个字节0100 0011 而UTF-8其实是可以看作是一种偷懒，在Unicode字符集中明明白白清清楚楚地写着你是两个字节 1000 1000 1000 0001，o自然也是两个字节（宽字符集）0000 0000 0100 0011 ，然后UTF-8觉得o前面的0明明不写也不改变值啊，所以搞了两条规矩： （图片截取自字符编码笔记：ASCII，Unicode 和 UTF-8 ） 这样一来，当你告诉计算机这是UTF-8格式的数据时，计算机读到0100 0011时就知道，这个东西代表的时Unicode字符集中的0000 0000 0100 0011，即字符o，所以可以说，UTF-8是一种采用MBCS字符集策略（可变长）来实现Unicode字符集的一种字符编码（自我理解，可能不准确）。 UTF-16 也是可变长度的Unicode字符编码 采用2个字节或4个字节来表示Unicode编码 存在大小端的问题。由于有2个字节，比UTF-8就多了一个问题，在存字符的时候，是高8码位放入高字节，低8码位放入低字节还是相反高8码位放入低字节，低8码位放入低字节，第一种称为Little endian（LE，默认），第二种称为Big endian(BE) Unicode 规范定义，为了让计算机能够能识别打开的文本是用大头方式存储的还是小头方式存储的，在文件的开头部分增加一个表示顺序的字符零宽度非换行空格（zero width no-break space），如果这个字符是FEFF，则是大头；如果是FFFE，则是小头 与ASCII不兼容 以字母a为例子： UTF-32 是不可变长度的Unicode字符编码（因为一次4个字节，够长了。。） 采用4个字节来表示Unicode编码 大小端问题 UCS-2 也称标准Unicode编码，定长，每一次取2个字节作为Unicode码 大小端问题。 UCS-4 每一次取4个字节作为Unicode码 大小端问题 关于BOM的问题 这是Unicode规范定义的。 前面的大小端问题中零宽度非换行空格其实就是UTF-16的BOM。 对于UTF-8而言，BOM为EF BB BF 在Windows上带BOM的格式用的比较多，但是在Unix及Mac上用的不多 所以开发过程中能不用就尽量不用。用UTF-8 without BOM 最为稳妥（相对于用BOM来说） MIME编码 本来这一部分也想自己写一下，但是看到阮一峰的网络日志上有写得很好的文章(感谢作者)，便不写了。下面是相关的链接 Base64笔记 MIME笔记 参考 字符编码笔记：ASCII，Unicode 和 UTF-8 ANSI字符编码和Windows 1252 字符编码详解——彻底理解掌握编码知识，“乱码”不复存在 计算机字符编码详尽讲解 utf-8和Unicode的区别 - 简书 大小端存储模式精解","categories":[{"name":"tech","slug":"tech","permalink":"https://hexo.kbrx93.com/categories/tech/"}],"tags":[{"name":"encoding","slug":"encoding","permalink":"https://hexo.kbrx93.com/tags/encoding/"}]},{"title":"markdown图片批量下载小工具","slug":"2017-11-07markdown图片批量下载小工具","date":"2017-11-06T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"other/markdown_img_download/","link":"","permalink":"https://hexo.kbrx93.com/other/markdown_img_download/","excerpt":"前言：针对markdown文件的批量上传及批量迁移，对应已经有很好的图形化工具ipic及ipic mover，但是没有将图片批量下载备份到本地的小工具，于是自己动手写了一个。","text":"前言：针对markdown文件的批量上传及批量迁移，对应已经有很好的图形化工具ipic及ipic mover，但是没有将图片批量下载备份到本地的小工具，于是自己动手写了一个。 主要环境及工具 平台：mac 10.12.6 工具：pycharm2017.2.4 语言：python3.6.2 主要思路 假设给出的参数是一个md文件 写成一个方法def save_img(file_allname) 用os.path.splitext获得对应的文件路径和文件后缀 生成对应的文件夹 拼接对应的图片本地路径 用正则表达式r'!\\[.*\\]\\((.+)\\)'将文件中的图片链接找出来 用urllib.request将图片下载下来并保存到指定位置 假设给出的参数是一个md文件目录 用os.listdir遍历 如果是文件夹，递归调用 如果是md文件，调用save_img 如果不是md文件，pass 具体源码查看 遇到的问题 首先在打开文件的时候，遇到编码问题 在打开md文件的时候，报错，提示 经查询后知晓这个问题一般出现python2.X上，解决方法如下： import sys default_encoding = 'utf-8' if sys.getdefaultencoding() != default_encoding: reload(sys) sys.setdefaultencoding(default_encoding) 但是尝试后发现问题依旧存在，最后在stackoverflow上找到解决方法： f= codecs.open('out_file','w',encoding='utf8') SSL问题 在下载https链接的图片的时候，会出现以下问题： Google后得知，Python 2.7.9 之后引入了一个新特性当你urllib.urlopen一个 https 的时候会验证一次 SSL 证书 当目标使用的是自签名的证书时就会爆出一个 urllib2.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:581)&gt;的错误消息 具体解决方法有两种： 导入ssl时关闭证书验证（我用这种解决了问题） import ssl ssl._create_default_https_context = ssl._create_unverified_context 使用ssl创建未经验证的上下文，在urlopen中传入上下文参数（没有尝试过，作记录用） import ssl import urllib2 context = ssl._create_unverified_context() print urllib2.urlopen(\"https://www.111cn.net/\", context=context).read() 使用os.listdir的问题 用os.listdir获得文件夹下所有文件包括子文件夹的名称时，仅包括文件、子文件夹的名称，不是整个文件路径（即不包括父文件夹的路径），故需要进行名称的拼接操作 正则表达式的问题 两个中括号要转义 对于正则表达式的不熟悉，导致写个筛选链接的表达式都用了很久，需要提高 参考 Python中文处理 python用requests请求百度接口报“SSL: CERTIFICATE_VERIFY_FAILED”","categories":[{"name":"other","slug":"other","permalink":"https://hexo.kbrx93.com/categories/other/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://hexo.kbrx93.com/tags/markdown/"},{"name":"image","slug":"image","permalink":"https://hexo.kbrx93.com/tags/image/"}]},{"title":"Hexo的源码保存过程小记","slug":"2017-11-03Hexo的源码保存过程小记","date":"2017-11-02T16:00:00.000Z","updated":"2018-11-24T16:57:31.000Z","comments":true,"path":"other/hexo_source2github/","link":"","permalink":"https://hexo.kbrx93.com/other/hexo_source2github/","excerpt":"前言：由于差一点把调整过的hexo源码搞不见了，便想着将hexo的源码保存在云上，主要是利用github的分支，将hexo的源码和hexo的发布文件保存到同一个respository,从而进行不同电脑平台上的同步。","text":"前言：由于差一点把调整过的hexo源码搞不见了，便想着将hexo的源码保存在云上，主要是利用github的分支，将hexo的源码和hexo的发布文件保存到同一个respository,从而进行不同电脑平台上的同步。 主要环境及前期准备： 采用比较主流的git 远程平台采用github 本机系统为Win10 其它电脑系统选用Mac10.12（基本过程类win，细节些微不同） 基本过程（主要分为以下几种情况） 在本机上初次Push 在本机上后续Push 在其它电脑上初次Pull 在其它电脑上后续Push ​ 在本机上初次Push 这个是主要过程，后续的过程只是一些不同及改动 主要步骤 0. 假设你已经成功建好了Hexo并可以访问 打开gitBash，cd到你的hexo根目录，执行git init，将根目录初始化为一个本地repository 执行git remote add origin git@github.com:kbrx93/kbrx93.github.io.git,注意修改成你自己的地址，HTTPS或SSH都可以，这一步的主要目是将本地的origin绑定到远程的repository,以便后续的Push 执行git add . 将所有的文件加到暂存区 执行git commit -m &quot;add hexo code firstly&quot;,将文件及文件改动加到本地版本库 最后执行git push origin master:source ,将源码Push到远程仓库的source分支。 （可不做）为了在网页上一进行就显示hexo的源码，可以将你新建保存源码的分支设为默认分支 具体做法如下： 遇到的问题 根目录的.gitconfig文件一般写上需要忽略的文件及文件夹 .DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ 一般下载的主题文件夹是github下载的，内有.git文件夹，需要删除才能正常add、commit，如果还不能成功的话将文件夹移出根目录，git add 、git commit一下，然后再移进来，再git add 、git commit一下，一般就可以。 push的时候，可以先在github上新建一个分支，再push；也可以直接在命令行新建然后push。 同样，在push的时候，我的情况是使用git push origin master:source成功，但是直接使用git push origin source却报错，具体原因有待后面对git的学习。 查看是否add成功可以用基本命令git status 根目录下配置文件中的git要有如下配置（一般都有配置，写出来提醒一下） deploy: type: git repo: git@github.com:kbrx93/kbrx93.github.io.git branch: master #注意这个一定是master分支，这个是github的限制，发布的网页一定要在这个分支 ​ 在本机上后续Push 主要步骤 在source/_posts目录下编写markdown文章，预览完成 Push源码 git add . git commit -m &quot;相关的信息&quot; git push origin master:source 发布(建议写本脚本直接运行，方便) hexo clean hexo g hexo d 更新搜索的索引（我这里用的是algolia，就是hexo algolia） 遇到的问题 发布的文章mathjax不正常，更换markdown渲染引擎pandoc 更换pandoc-github 遇到没有提交成功，多看看git status 在其它电脑上初次Pull(Mac) 主要步骤 前提是安装好了hexo，git及npm（最好将其改为淘宝源cnpm，速度快） 先建一个文件夹hexo，然后从github上clone下来你的hexo源码，具体代 git clone https://github.com/kbrx93/kbrx93.github.io.git,注意是源码，不是静态网页 cd 到这个文件夹里去，执行下列的命令 npm install hexo // 安装hexo 安装完成hexo 不需要初始化hexo，否者hexo 配置参数会重置 npm install // 安装依赖库 npm install hexo-deployer-git --save // 安装部署相关配置 //如果你有安装了其它的东西，也要重新安装 例：hexo-renderer-pandoc和algolia等 进行这一步的主要原因是在上一步的那个.giticonfig文件中将node_modules/文件夹忽略了，故没有了相关的程序，需要重新安装，至于将这个文件夹归入git管理的情况，个人没有尝试，故在这里不再多言。 发布文章 相关的步骤同 在本机上后续Push 遇到的问题 这里的问题主要是pandoc的问题，用brew install pandoc 安装完pandoc后，想用 hexo-renderer-pandoc调用pandoc的时候出错了，我这里的问题是调用时所加的++smart参数问题，应该是hexo-renderer-pandoc的问题，这个参数的形式改动了，（奇怪的是在Win下并没有这个问题），解决方法是修改对应文件根目录\\node_modules\\hexo-renderer-pandoc\\index.js里的参数即可。 在其它电脑上后续Push 同在本机上后续Push 参考 hexo+next+博客源码+坑","categories":[{"name":"other","slug":"other","permalink":"https://hexo.kbrx93.com/categories/other/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://hexo.kbrx93.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://hexo.kbrx93.com/tags/github/"}]}]}