---
title: 计算机编码学习小记-字符编码、MIME编码
date: 2017-11-09
tags: encoding
categories: tech
urlname: computer_character_encoding
---
***

前言：写这一篇文章的动机主要是在前面做[markdown图片批量下载小工具](https://kbrx93.com/other/markdown_img_download/)时遇到过编码问题，发现自己对于计算机内部的编码了解甚少，于是想较为系统地学习一下。这篇笔记记录的主要是计算机内部的编码，至于在网络传输过程中编码的过程和问题以及在各种编程语言中的编码问题不在讨论范围之中，如果以后有时间或者有需要再写吧。不对或不妥之处，请批评指正。

![](https://image-1251774567.cosgz.myqcloud.com/201801211407_325.png)

<!--more-->

## 准备知识

> 1. 什么是[计算机编码](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81)？

在我们日常生活中，用各种各样的语言进行交流，而每一种语言实际上就是一套字符集合，中文的“你”，英文的“you”等，都是字符。这没有任何问题，但是对于计算机来说，问题就出现了，它只认识 0 和 1 ，其它的什么东西都不认识。

- 于是对于计算机而言，就需要一个表，当你输入`y`保存的时候，它去这个表里查对应的`01序列`（*假设`y`对应的是`000110`* ），找到了对应的`01序列`后就将其保存磁盘上
- 下一次你要打开这个文件，计算机就去找表里对应`000110`的字符是什么，知道这个字符是`y`后，就显示出来（*经过其它操作*）
- 于是`y`在计算机中变成`000110`的过程就叫**编码**（*编成01代码串*），相反过来从`000110`到`y`的过程叫**解码**。
- 还有因为`000110`对于人来说可能看得不直观，我们一般将其转化为十进制表示（在这里就是`6`），所以可以说`y`就对应表中的`6`

> 2. 什么是[字符集](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81)？什么是[字符编码](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81)？两者的区别是什么？

- 前面说了，生活中使用到的字符需要经过编码才能让计算机识别和使用，所以关键就是那张让计算机进行转化的**表**
- 字符集说白了就是这张表，这张表里规定了**整数**10代表了哪个字符，11代表了哪个字符，12代表了哪个字符之类的。
- 字符编码是指有了这张表，我们如何进行编制的问题，举个例子来说明可能容易理解一些：假设在表中（*捏造的*）
  - 1 代表了字符`o`
  - 20 代表了字符`k`
- 计算机读取 3 个字节，发现是`0000 0000 0001 `，明白了：哦，原来这个字符是`o`，再读取3个字节，发现是`1100 0001 1110`，明白了：原来这个字符是`k`。看上去没有问题，一切都很完美。但是，对于第一个字符来说，为什么不省略前面的8个0，只写`0001`就让计算机知道：哦，这个是`o`呢？
- 所以，经过上面的例子我们可以知道，这张表规定了`1`代表了一个字符，但是`1` 用`01序列`表示的话，可以表示成`0001`，也可以表示成`0000 0001`,这就是不同的字符编码方式，也就是告诉计算机一次该读几个字节（定长）或者读取到什么信息就结束读取进行转化（可变长），然后去表中查找相应的字符，这样的一套编码方式就叫***字符编码***。（关于`定长`和`可变长`参看后面，这里不理解可以先跳过）
- ***特别注意***，`GBK`及`ASCII`等，既可以指一张表（字符集），又指字符编码。这张表里8个bit代表一个字符，那计算机你就每次读8位，再看看对应什么字符好了。但是对于更大的字符集（如Unicode）而言，每次读4个字节太浪费时间（如上面的例子），用`0001`还是用`0000 0001`来表示表中的1就成了问题，所以针对Unicode来说有不同的字符编码方式（UTF-8、UTF-16之类的）。

>3. 什么是[内码](https://zh.wikipedia.org/wiki/%E5%85%A7%E7%A2%BC)？

个人觉得就是**字符集**。

## 主要内容

### 字符编码

经过上面的解释，我们可以知道计算机需要一张**表**，但是呢，世界上有很多种语言，所以不同地区的计算机上的**表**其实是不一样的。。。所有就有了乱码问题。

> 计算机字符集可分为三类：单字节字符集(SBCS)、多字节字符集(MBCS)和宽字符集(即Unicode字符集)。
>
> 1.  单字节字符集(SBCS)：表中的`01序列`为一个字节（8bit），即用一个字节一个字符，如：ACSII
>
> 2.  多字节字符集(MBCS)：表中的`01序列`为一个或多个字节，即用一个或多个字节表示一个字符，如ANSI中的各种字符集
>
> 3.  宽字符集(即Unicode字符集)：表中的`01序列`为2个字节，即用两个字节表示一个字符。（刚出来是2个字节，后来发现不够用，已更新了一组附加字符编码，用4个字节表示一个字符）

以下介绍几种常用的字符编码，更加全面请参考百科[字符编码](https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81)

- [ASCII](https://zh.wikipedia.org/wiki/ASCII)

  * 大小为 `1` 个字节（8bit，可表示0～255共256个数），格式为`0XXXXXXX`
  * 填入了英文字符及一些不可见字符（如换行等）
  * 填入后发现只用了一半的编码（128个字符），但为了便于传输和保存，干脆在前面增加一个`0`，这样刚好湊够一个字节

* [EASCII](https://zh.wikipedia.org/wiki/EASCII)

  * 大小为`1`个字节，格式为`1XXXXXXX`
  * 对ASCII的扩展，用了ASCII没用完的后面码位

  - [ISO/IEC 8859-1](https://zh.wikipedia.org/wiki/ISO/IEC_8859-1)

    这个是比较常见的ASCII扩展字符集

- [ANSI](https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9C%8B%E5%9C%8B%E5%AE%B6%E6%A8%99%E6%BA%96%E5%8D%94%E6%9C%83)

  - 在最开始，ANSI指的是Windows自己设计的一套编码，对应的在Code Page号是1252，被称为Windows 1252。由于ANSI是大部分参照（可以说基本一样）`ANSI草案`(ANSI Draft)，后来这个`ANSI草案`最终正为了一个正式标准`ISO 8859-1`，所以最开始的`ANSI`字符集和`ISO 8859-1`基本一样。

  - 但是现在来说，大多数人口中的ANSI编码并不是指代一套特定的编码，而是是`本地编码`，可能在简体中文的Windows系统上ANSI指`GB2312`，在日文Windows系统上ANSI编码代表 JIS 编码等。（*注意，ANSI是在ASCII的基础上进行扩展的，故向下兼容ASCII*）

  - 中文 GB2312、GBK、GB18030

    关系：ASCII ==〉GB2313 ==〉GBK ==〉GB18030 （包含的内容递增，并向下兼容）

    由于中文编码较为复杂，具体可以看下[字符编码详解——彻底理解掌握编码知识，“乱码”不复存在](http://polaris.blog.51cto.com/1146394/377468/)中GB编码部分，如遇需要再做记录。

- [Unicode](https://zh.wikipedia.org/wiki/Unicode)

  > 注意，网络上有的文章说Unicode是2个字节，有的说是4个，这是因为Unicode刚出来的时候2个字节来就足够编码了，但在发展过程中发现65536个码位不够用，就更新了规范，增加了辅助平面，用4个字节来表示新增的字符，而之前的常用编码保持不变，称为基本多文种平面（BMP），编码从U+0000至U+FFFF，更具体的可以参见百科。

  - [UTF-8](https://zh.wikipedia.org/wiki/UTF-8)
    - 可变长度Unicode字符编码
    - 采用1～4个字节来表示Unicode码

  > ***注意Unicode中的UTF-8是可变长的多个字节，前面的MBCS字符集也是多个字节，有什么区别？***

  - MBCS字符集即表中中文`你`可能就是两个字节`1000 1000 1000 0001`，而`o`则是一个字节`0100 0011`

  - 而UTF-8其实是可以看作是一种`偷懒`，在Unicode字符集中明明白白清清楚楚地写着`你`是两个字节

    `1000 1000 1000 0001`，`o`自然也是两个字节（*宽字符集*）`0000 0000 0100 0011` ，然后UTF-8觉得o前面的0明明不写也不改变值啊，所以搞了两条规矩：

    ![](https://image-1251774567.cosgz.myqcloud.com/2018-01-24-200633.png)

    （图片截取自[字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html) ）

  - 这样一来，当你告诉计算机这是UTF-8格式的数据时，计算机读到`0100 0011`时就知道，这个东西代表的时Unicode字符集中的`0000 0000 0100 0011`，即字符`o`，所以可以说，***UTF-8是一种采用MBCS字符集策略（可变长）来实现Unicode字符集的一种字符编码***（自我理解，可能不准确）。


  - [UTF-16](https://zh.wikipedia.org/wiki/UTF-16)

    - 也是可变长度的Unicode字符编码

    - 采用2个字节或4个字节来表示Unicode编码

    - 存在大小端的问题。由于有2个字节，比UTF-8就多了一个问题，在存字符的时候，是`高8码位放入高字节，低8码位放入低字节`还是`相反高8码位放入低字节，低8码位放入低字节`，第一种称为`Little endian`（LE，默认），第二种称为` Big endian`(BE)

      Unicode 规范定义，为了让计算机能够能识别打开的文本是用`大头`方式存储的还是`小头`方式存储的，在文件的开头部分增加一个表示顺序的字符`零宽度非换行空格（zero width no-break space）`，如果这个字符是`FEFF`，则是大头；如果是`FFFE`，则是小头
    - ***与ASCII不兼容***

      以字母`a`为例子：

      ![](https://image-1251774567.cosgz.myqcloud.com/2017-12-28-124138.png)


  - [UTF-32](https://zh.wikipedia.org/zh-hans/UTF-32)
    - 是`不可变长度`的Unicode字符编码（因为一次4个字节，够长了。。）
    - 采用4个字节来表示Unicode编码
    - 大小端问题
  - UCS-2
    - 也称标准Unicode编码，定长，每一次取2个字节作为Unicode码
    - 大小端问题。
  - UCS-4
    - 每一次取4个字节作为Unicode码
    - 大小端问题

- 关于BOM的问题

  - 这是Unicode规范定义的。
  - 前面的大小端问题中`零宽度非换行空格`其实就是UTF-16的BOM。
  - 对于UTF-8而言，BOM为`EF BB BF`
  - 在Windows上带BOM的格式用的比较多，但是在Unix及Mac上用的不多
  - 所以开发过程中能不用就尽量不用。用UTF-8 without BOM 最为稳妥（相对于用BOM来说）

### MIME编码

本来这一部分也想自己写一下，但是看到`阮一峰的网络日志`上有写得很好的文章(感谢作者)，便不写了。下面是相关的链接

- [Base64笔记](http://www.ruanyifeng.com/blog/2008/06/base64.html)
- [MIME笔记](http://www.ruanyifeng.com/blog/2008/06/mime.html)

## 参考

- [字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)
- [ANSI字符编码和Windows 1252](https://www.crifan.com/files/doc/docbook/char_encoding/release/webhelp/windows1252_vs_iso8859_1.html)
- [字符编码详解——彻底理解掌握编码知识，“乱码”不复存在](http://polaris.blog.51cto.com/1146394/377468/)
- [计算机字符编码详尽讲解](https://www.cnblogs.com/kex1n/p/4138427.html)
- [utf-8和Unicode的区别 - 简书](http://www.jianshu.com/p/36d20de2a1ee)
- [大小端存储模式精解](https://jocent.me/2017/07/25/big-little-endian.html)

